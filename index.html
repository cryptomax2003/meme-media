<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MEME MEDIA | The Future of Meme Finance</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    
    <script>
        // ==========================================
        // YOUR FIREBASE CONFIGURATION
        // ==========================================
        const firebaseConfig = {
            apiKey: "AIzaSyDJUuShTLtA7vo2P67KX425ySL1lJ4Q_lo",
            authDomain: "mememedia-832af.firebaseapp.com",
            projectId: "mememedia-832af",
            storageBucket: "mememedia-832af.firebasestorage.app",
            messagingSenderId: "1014463566582",
            appId: "1:1014463566582:web:65e563f4f0f787626852d7"
        };
        
        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const db = firebase.firestore();
        const auth = firebase.auth();
        
        window.app = {
            data: {
                currentUser: null,
                users: [],
                posts: [],
                currentTab: 'all',
                currentCategory: 'All',
                searchQuery: '',
                authMode: 'login',
                verificationCode: null,
                codeExpiry: null,
                view: 'home',
                profileViewUser: null,
                codeDisplayTimeout: null,
                expandedComments: new Set(),
                expandedReplies: new Set(),
                postsListener: null,
                usersListener: null,
                notificationsListener: null,
                messagesListener: null,
                submittingPost: false,
                submittingComment: false,
                submittingReply: false,
                currentChat: null,
                highlightedComment: null,
                highlightedReply: null,
                suspendCountdownInterval: null
            },

            admins: ['cryptomax172003@gmail.com'],
            
            // Country list for selection
            countries: [
                { code: 'AF', name: 'Afghanistan', timezone: 'Asia/Kabul' },
                { code: 'AL', name: 'Albania', timezone: 'Europe/Tirane' },
                { code: 'DZ', name: 'Algeria', timezone: 'Africa/Algiers' },
                { code: 'AR', name: 'Argentina', timezone: 'America/Argentina/Buenos_Aires' },
                { code: 'AU', name: 'Australia', timezone: 'Australia/Sydney' },
                { code: 'AT', name: 'Austria', timezone: 'Europe/Vienna' },
                { code: 'BD', name: 'Bangladesh', timezone: 'Asia/Dhaka' },
                { code: 'BE', name: 'Belgium', timezone: 'Europe/Brussels' },
                { code: 'BR', name: 'Brazil', timezone: 'America/Sao_Paulo' },
                { code: 'CA', name: 'Canada', timezone: 'America/Toronto' },
                { code: 'CN', name: 'China', timezone: 'Asia/Shanghai' },
                { code: 'CO', name: 'Colombia', timezone: 'America/Bogota' },
                { code: 'HR', name: 'Croatia', timezone: 'Europe/Zagreb' },
                { code: 'CZ', name: 'Czech Republic', timezone: 'Europe/Prague' },
                { code: 'DK', name: 'Denmark', timezone: 'Europe/Copenhagen' },
                { code: 'EG', name: 'Egypt', timezone: 'Africa/Cairo' },
                { code: 'FI', name: 'Finland', timezone: 'Europe/Helsinki' },
                { code: 'FR', name: 'France', timezone: 'Europe/Paris' },
                { code: 'DE', name: 'Germany', timezone: 'Europe/Berlin' },
                { code: 'GR', name: 'Greece', timezone: 'Europe/Athens' },
                { code: 'HK', name: 'Hong Kong', timezone: 'Asia/Hong_Kong' },
                { code: 'HU', name: 'Hungary', timezone: 'Europe/Budapest' },
                { code: 'IN', name: 'India', timezone: 'Asia/Kolkata' },
                { code: 'ID', name: 'Indonesia', timezone: 'Asia/Jakarta' },
                { code: 'IR', name: 'Iran', timezone: 'Asia/Tehran' },
                { code: 'IQ', name: 'Iraq', timezone: 'Asia/Baghdad' },
                { code: 'IE', name: 'Ireland', timezone: 'Europe/Dublin' },
                { code: 'IL', name: 'Israel', timezone: 'Asia/Jerusalem' },
                { code: 'IT', name: 'Italy', timezone: 'Europe/Rome' },
                { code: 'JP', name: 'Japan', timezone: 'Asia/Tokyo' },
                { code: 'JO', name: 'Jordan', timezone: 'Asia/Amman' },
                { code: 'KE', name: 'Kenya', timezone: 'Africa/Nairobi' },
                { code: 'KW', name: 'Kuwait', timezone: 'Asia/Kuwait' },
                { code: 'LB', name: 'Lebanon', timezone: 'Asia/Beirut' },
                { code: 'MY', name: 'Malaysia', timezone: 'Asia/Kuala_Lumpur' },
                { code: 'MX', name: 'Mexico', timezone: 'America/Mexico_City' },
                { code: 'MA', name: 'Morocco', timezone: 'Africa/Casablanca' },
                { code: 'NL', name: 'Netherlands', timezone: 'Europe/Amsterdam' },
                { code: 'NZ', name: 'New Zealand', timezone: 'Pacific/Auckland' },
                { code: 'NG', name: 'Nigeria', timezone: 'Africa/Lagos' },
                { code: 'NO', name: 'Norway', timezone: 'Europe/Oslo' },
                { code: 'PK', name: 'Pakistan', timezone: 'Asia/Karachi' },
                { code: 'PE', name: 'Peru', timezone: 'America/Lima' },
                { code: 'PH', name: 'Philippines', timezone: 'Asia/Manila' },
                { code: 'PL', name: 'Poland', timezone: 'Europe/Warsaw' },
                { code: 'PT', name: 'Portugal', timezone: 'Europe/Lisbon' },
                { code: 'QA', name: 'Qatar', timezone: 'Asia/Qatar' },
                { code: 'RO', name: 'Romania', timezone: 'Europe/Bucharest' },
                { code: 'RU', name: 'Russia', timezone: 'Europe/Moscow' },
                { code: 'SA', name: 'Saudi Arabia', timezone: 'Asia/Riyadh' },
                { code: 'SG', name: 'Singapore', timezone: 'Asia/Singapore' },
                { code: 'ZA', name: 'South Africa', timezone: 'Africa/Johannesburg' },
                { code: 'KR', name: 'South Korea', timezone: 'Asia/Seoul' },
                { code: 'ES', name: 'Spain', timezone: 'Europe/Madrid' },
                { code: 'SE', name: 'Sweden', timezone: 'Europe/Stockholm' },
                { code: 'CH', name: 'Switzerland', timezone: 'Europe/Zurich' },
                { code: 'TW', name: 'Taiwan', timezone: 'Asia/Taipei' },
                { code: 'TH', name: 'Thailand', timezone: 'Asia/Bangkok' },
                { code: 'TR', name: 'Turkey', timezone: 'Europe/Istanbul' },
                { code: 'UA', name: 'Ukraine', timezone: 'Europe/Kiev' },
                { code: 'AE', name: 'United Arab Emirates', timezone: 'Asia/Dubai' },
                { code: 'GB', name: 'United Kingdom', timezone: 'Europe/London' },
                { code: 'US', name: 'United States', timezone: 'America/New_York' },
                { code: 'VN', name: 'Vietnam', timezone: 'Asia/Ho_Chi_Minh' },
                { code: 'YE', name: 'Yemen', timezone: 'Asia/Aden' }
            ],

            async init() {
                console.log('App initializing with Firebase...');
                this.setupEventListeners();
                await this.checkAuth();
                console.log('App initialized successfully');
            },

            // ==========================================
            // REAL-TIME FIREBASE LISTENERS
            // ==========================================
            
            setupRealtimeListeners() {
                this.stopRealtimeListeners();
                
                this.data.postsListener = db.collection('posts')
                    .orderBy('timestamp', 'desc')
                    .onSnapshot((snapshot) => {
                        this.data.posts = [];
                        snapshot.forEach((doc) => {
                            this.data.posts.push({ id: doc.id, ...doc.data() });
                        });
                        console.log('Real-time posts update:', this.data.posts.length, 'posts');
                        this.renderPosts();
                        if (this.data.view === 'profile') {
                            this.renderProfile(this.data.profileViewUser);
                        }
                    }, (error) => {
                        console.error('Posts listener error:', error);
                    });

                this.data.usersListener = db.collection('users')
                    .onSnapshot((snapshot) => {
                        this.data.users = [];
                        snapshot.forEach((doc) => {
                            this.data.users.push({ email: doc.id, ...doc.data() });
                        });
                        console.log('Real-time users update:', this.data.users.length, 'users');
                        
                        if (this.data.currentUser) {
                            const updatedUser = this.data.users.find(u => u.email === this.data.currentUser.email);
                            if (updatedUser) {
                                this.data.currentUser = { ...this.data.currentUser, ...updatedUser };
                            }
                        }
                        
                        if (this.data.view === 'profile') {
                            this.renderProfile(this.data.profileViewUser);
                        } else if (this.data.view === 'followers') {
                            const followersTitle = document.getElementById('followersListTitle');
                            if (followersTitle) {
                                const type = followersTitle.innerText === 'Followers' ? 'followers' : 'following';
                                this.renderFollowersList({ 
                                    type: type, 
                                    userEmail: this.data.profileViewUser || this.data.currentUser?.email 
                                });
                            }
                        } else if (this.data.view === 'messages') {
                            this.renderMessagesList();
                        } else if (this.data.view === 'chat') {
                            this.renderChat(this.data.currentChat);
                        }
                    }, (error) => {
                        console.error('Users listener error:', error);
                    });

                if (this.data.currentUser) {
                    this.setupNotificationsListener();
                    this.setupMessagesListener();
                }
            },

            setupMessagesListener() {
                if (this.data.messagesListener) {
                    this.data.messagesListener();
                }
                
                // Listen to conversations where current user is a participant
                this.data.messagesListener = db.collection('conversations')
                    .where('participants', 'array-contains', this.data.currentUser.email)
                    .onSnapshot((snapshot) => {
                        console.log('Conversations updated:', snapshot.size);
                        if (this.data.view === 'messages') {
                            this.renderMessagesList();
                        } else if (this.data.view === 'chat' && this.data.currentChat) {
                            this.renderChat(this.data.currentChat);
                        }
                    }, (error) => {
                        console.error('Messages listener error:', error);
                    });
            },

            setupNotificationsListener() {
                if (this.data.notificationsListener) {
                    this.data.notificationsListener();
                }
                
                const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);
                
                this.data.notificationsListener = db.collection('notifications')
                    .where('targetUser', '==', this.data.currentUser.email)
                    .onSnapshot((snapshot) => {
                        const notifications = [];
                        snapshot.forEach((doc) => {
                            const data = doc.data();
                            if (data.timestamp > twentyFourHoursAgo) {
                                notifications.push({ id: doc.id, ...data });
                            }
                        });
                        notifications.sort((a, b) => b.timestamp - a.timestamp);
                        this.updateNotificationBadge(notifications.length);
                    }, (error) => {
                        console.error('Notifications listener error:', error);
                    });
            },

            updateNotificationBadge(count) {
                const badge = document.getElementById('notificationBadge');
                if (badge) {
                    if (count > 0) {
                        badge.innerText = count > 99 ? '99+' : count;
                        badge.classList.remove('hidden');
                    } else {
                        badge.classList.add('hidden');
                    }
                }
            },

            stopRealtimeListeners() {
                if (this.data.postsListener) {
                    this.data.postsListener();
                    this.data.postsListener = null;
                }
                if (this.data.usersListener) {
                    this.data.usersListener();
                    this.data.usersListener = null;
                }
                if (this.data.notificationsListener) {
                    this.data.notificationsListener();
                    this.data.notificationsListener = null;
                }
                if (this.data.messagesListener) {
                    this.data.messagesListener();
                    this.data.messagesListener = null;
                }
            },

            // ==========================================
            // AUTHENTICATION
            // ==========================================
            
            async checkAuth() {
                auth.onAuthStateChanged(async (user) => {
                    if (user) {
                        const userDoc = await db.collection('users').doc(user.email).get();
                        if (userDoc.exists) {
                            this.data.currentUser = { email: user.email, ...userDoc.data() };
                            this.setupRealtimeListeners();
                            this.updateAuthUI();
                            this.navigate('home');
                        } else {
                            const newUser = {
                                tag: user.email.split('@')[0],
                                displayName: user.email.split('@')[0],
                                pic: '',
                                following: [],
                                followers: [],
                                lastPostDate: null,
                                postsToday: 0,
                                createdAt: Date.now(),
                                country: 'US',
                                timezone: 'America/New_York',
                                lastTagChange: null,
                                suspended: null,
                                blockedUsers: []
                            };
                            await db.collection('users').doc(user.email).set(newUser);
                            this.data.currentUser = { email: user.email, ...newUser };
                            this.setupRealtimeListeners();
                            this.updateAuthUI();
                            this.navigate('home');
                        }
                    } else {
                        this.data.currentUser = null;
                        this.stopRealtimeListeners();
                        this.data.posts = [];
                        this.data.users = [];
                        this.updateAuthUI();
                        this.renderPosts();
                    }
                });
            },

            // ==========================================
            // NAVIGATION
            // ==========================================
            
            navigate(viewName, param = null) {
                console.log('Navigating to:', viewName);
                this.data.view = viewName;
                
                const views = ['homeView', 'createPostView', 'profileView', 'searchUserView', 'followersView', 'notificationsView', 'imageView', 'faqView', 'messagesView', 'chatView'];
                views.forEach(v => {
                    const el = document.getElementById(v);
                    if (el) el.classList.add('hidden');
                });

                const viewMap = {
                    'home': 'homeView',
                    'create': 'createPostView',
                    'profile': 'profileView',
                    'search': 'searchUserView',
                    'followers': 'followersView',
                    'notifications': 'notificationsView',
                    'image': 'imageView',
                    'faq': 'faqView',
                    'messages': 'messagesView',
                    'chat': 'chatView'
                };

                const targetView = document.getElementById(viewMap[viewName]);
                if (targetView) {
                    targetView.classList.remove('hidden');
                }

                if (viewName === 'home') {
                    this.renderPosts();
                } else if (viewName === 'create') {
                    this.setupCreatePost();
                } else if (viewName === 'profile') {
                    this.renderProfile(param);
                } else if (viewName === 'followers') {
                    this.renderFollowersList(param);
                } else if (viewName === 'notifications') {
                    this.renderNotifications();
                } else if (viewName === 'messages') {
                    this.renderMessagesList();
                } else if (viewName === 'chat') {
                    this.data.currentChat = param;
                    this.renderChat(param);
                }
                
                window.scrollTo(0, 0);
            },

            setupCreatePost() {
                const postTypeSection = document.getElementById('postTypeSection');
                if (postTypeSection) {
                    if (this.data.currentUser && this.admins.includes(this.data.currentUser.email)) {
                        postTypeSection.classList.remove('hidden');
                    } else {
                        postTypeSection.classList.add('hidden');
                    }
                }
            },

            switchTab(tab) {
                this.data.currentTab = tab;
                
                const allBtn = document.getElementById('tab-all');
                const topBtn = document.getElementById('tab-top');
                const controls = document.getElementById('allNewsControls');

                if (tab === 'all') {
                    allBtn?.classList.add('bg-green-500/10', 'text-green-400', 'border-green-500/30');
                    allBtn?.classList.remove('bg-gray-900', 'text-gray-400', 'border-gray-700');
                    
                    topBtn?.classList.remove('bg-pink-500/10', 'text-pink-400', 'border-pink-500/30');
                    topBtn?.classList.add('bg-gray-900', 'text-gray-400', 'border-gray-700');
                    
                    controls?.classList.remove('hidden');
                } else {
                    topBtn?.classList.add('bg-pink-500/10', 'text-pink-400', 'border-pink-500/30');
                    topBtn?.classList.remove('bg-gray-900', 'text-gray-400', 'border-gray-700');
                    
                    allBtn?.classList.remove('bg-green-500/10', 'text-green-400', 'border-green-500/30');
                    allBtn?.classList.add('bg-gray-900', 'text-gray-400', 'border-gray-700');
                    
                    controls?.classList.add('hidden');
                }
                this.renderPosts();
            },

            setCategory(cat) {
                this.data.currentCategory = cat;
                
                document.querySelectorAll('.category-pill').forEach(btn => {
                    const btnText = btn.innerText.replace(/[^\w\s]/g, '').trim();
                    if ((cat === 'All' && btnText === 'All') || btnText === cat) {
                        btn.classList.add('active');
                    } else {
                        btn.classList.remove('active');
                    }
                });
                this.renderPosts();
            },

            filterPosts() {
                const searchInput = document.getElementById('searchInput');
                this.data.searchQuery = searchInput ? searchInput.value.toLowerCase() : '';
                this.renderPosts();
            },

            toggleComments(postId) {
                if (this.data.expandedComments.has(postId)) {
                    this.data.expandedComments.delete(postId);
                } else {
                    this.data.expandedComments.add(postId);
                }
                // Re-render based on current view
                if (this.data.view === 'profile') {
                    this.renderProfile(this.data.profileViewUser);
                } else {
                    this.renderPosts();
                }
            },

            toggleReplies(replyId) {
                if (this.data.expandedReplies.has(replyId)) {
                    this.data.expandedReplies.delete(replyId);
                } else {
                    this.data.expandedReplies.add(replyId);
                }
                // Re-render based on current view
                if (this.data.view === 'profile') {
                    this.renderProfile(this.data.profileViewUser);
                } else {
                    this.renderPosts();
                }
            },

            formatCommentText(text) {
                return text.replace(/@(\w+)/g, '<span class="text-blue-400 font-bold hover:underline cursor-pointer">@$1</span>');
            },

            // ==========================================
            // TIME FORMATTING WITH TIMEZONE
            // ==========================================
            
            formatDateTime(timestamp, userTimezone = null) {
                if (!timestamp) return '';
                const tz = userTimezone || this.data.currentUser?.timezone || 'America/New_York';
                const date = new Date(timestamp);
                return date.toLocaleString('en-US', {
                    timeZone: tz,
                    year: 'numeric',
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            },

            // ==========================================
            // IMAGE VIEWER
            // ==========================================
            
            openImageViewer(imageUrl, postTitle) {
                const viewer = document.getElementById('imageViewer');
                const img = document.getElementById('viewerImage');
                const title = document.getElementById('viewerTitle');
                
                if (viewer && img) {
                    img.src = imageUrl;
                    if (title) title.innerText = postTitle || 'Image View';
                    viewer.classList.remove('hidden');
                    document.body.style.overflow = 'hidden';
                }
            },

            closeImageViewer() {
                const viewer = document.getElementById('imageViewer');
                if (viewer) {
                    viewer.classList.add('hidden');
                    document.body.style.overflow = '';
                }
            },

            // ==========================================
            // COMMENTS RENDERING HELPER - WITH NESTED REPLIES SUPPORT
            // ==========================================
            
            renderCommentsSection(post, isAdmin, containerId = null, highlightCommentIndex = null, highlightReplyIndices = null) {
                const allComments = (post.comments || []).sort((a, b) => b.timestamp - a.timestamp);
                const isExpanded = this.data.expandedComments.has(post.id);
                const displayedComments = isExpanded ? allComments : allComments.slice(0, 3);
                const hasMoreComments = allComments.length > 3;
                
                let commentsHtml = '';
                if (allComments.length > 0) {
                    const commentsList = displayedComments.map((c, index) => {
                        const commentId = `comment-${post.id}-${index}`;
                        const isRepliesExpanded = this.data.expandedReplies.has(commentId);
                        
                        // Check if this comment should be highlighted
                        const isHighlighted = highlightCommentIndex === index;
                        const highlightClass = isHighlighted ? 'bg-gray-600/50 ring-2 ring-gray-400/50' : 'bg-gray-800/30';
                        
                        // Build reply tree for this comment
                        const repliesHtml = this.buildReplyTree(c.replies || [], post.id, index, isAdmin, highlightReplyIndices);
                        
                        const canDeleteComment = isAdmin || this.data.currentUser?.tag === c.user;
                        
                        return `
                            <div class="text-xs text-gray-400 mb-3 p-2 rounded ${highlightClass}" id="${commentId}">
                                <div class="flex items-start justify-between">
                                    <div class="flex items-center gap-2">
                                        <span class="text-green-400 font-bold cursor-pointer hover:underline" 
                                              onclick="window.app.navigate('profile', '${this.getUserEmailByTag(c.user)}')">@${c.user}</span>
                                        <span class="text-gray-500">${this.formatDateTime(c.timestamp)}</span>
                                    </div>
                                    <div class="flex gap-2">
                                        <button onclick="window.app.showReplyModal('${post.id}', ${index}, null, '${c.user}')" 
                                                class="text-xs text-blue-400 hover:text-blue-300">Reply</button>
                                        ${canDeleteComment ? `
                                        <button onclick="window.app.deleteComment('${post.id}', ${index})" 
                                                class="text-xs text-red-400 hover:text-red-300">Delete</button>
                                        ` : ''}
                                    </div>
                                </div>
                                <div class="mt-1">${this.formatCommentText(c.text)}</div>
                                ${c.image ? `<img src="${c.image}" class="mt-2 max-h-32 rounded cursor-pointer hover:opacity-80" onclick="window.app.openImageViewer('${c.image}', 'Comment Image')">` : ''}
                                ${repliesHtml}
                            </div>
                        `;
                    }).join('');
                    
                    const readMoreBtn = hasMoreComments ? `
                        <button onclick="window.app.toggleComments('${post.id}')" class="text-xs text-blue-400 hover:text-blue-300 mb-2 font-medium">
                            ${isExpanded ? 'Read Less ↑' : `Read More (${allComments.length - 3} more) ↓`}
                        </button>
                    ` : '';
                    
                    commentsHtml = `<div class="mt-3 pt-3 border-t border-gray-700 space-y-1">
                        ${readMoreBtn}
                        ${commentsList}
                    </div>`;
                }
                
                return commentsHtml;
            },

            // FIXED: Build proper reply tree structure with correct parent-child relationships
            buildReplyTree(replies, postId, commentIndex, isAdmin, highlightReplyIndices, parentReplyIndex = null, depth = 0) {
                if (!replies || replies.length === 0) return '';
                
                // Get direct children of the current parent (null means direct children of comment)
                const directChildren = replies.filter((r, idx) => {
                    // If parentReplyIndex is null, we want replies with null/undefined parentReplyIndex
                    // If parentReplyIndex is a number, we want replies with matching parentReplyIndex
                    const replyParent = r.parentReplyIndex;
                    if (parentReplyIndex === null) {
                        return replyParent === null || replyParent === undefined;
                    }
                    return replyParent === parentReplyIndex;
                });
                
                if (directChildren.length === 0) return '';
                
                // Sort by timestamp (oldest first for thread continuity)
                directChildren.sort((a, b) => a.timestamp - b.timestamp);
                
                const childrenHtml = directChildren.map((reply) => {
                    // Find the actual index of this reply in the full replies array
                    const replyIndex = replies.findIndex(r => r.timestamp === reply.timestamp && r.user === reply.user && r.text === reply.text);
                    
                    const replyId = `reply-${postId}-${commentIndex}-${replyIndex}`;
                    const isExpanded = this.data.expandedReplies.has(replyId);
                    
                    // Recursively get children of this reply
                    const nestedChildren = this.buildReplyTree(replies, postId, commentIndex, isAdmin, highlightReplyIndices, replyIndex, depth + 1);
                    const hasNestedChildren = nestedChildren !== '';
                    
                    const canDeleteReply = isAdmin || this.data.currentUser?.tag === reply.user;
                    const isHighlighted = highlightReplyIndices && highlightReplyIndices.includes(replyIndex);
                    const highlightClass = isHighlighted ? 'bg-gray-600/50 ring-2 ring-gray-400/50' : '';
                    
                    const showRepliesBtn = hasNestedChildren ? `
                        <button onclick="window.app.toggleReplies('${replyId}')" class="text-xs text-blue-400 hover:text-blue-300 mt-1 font-medium">
                            ${isExpanded ? 'Hide Replies ↑' : `Show Replies (${this.countNestedReplies(replies, replyIndex)}) ↓`}
                        </button>
                    ` : '';
                    
                    const nestedHtml = isExpanded ? nestedChildren : '';
                    
                    return `
                        <div class="text-xs text-gray-400 p-2 rounded ${highlightClass} mt-2" id="${replyId}">
                            <div class="flex items-start gap-2">
                                <span class="text-green-400 font-bold cursor-pointer hover:underline" 
                                      onclick="window.app.navigate('profile', '${this.getUserEmailByTag(reply.user)}')">@${reply.user}</span>
                                <span class="text-gray-500">${this.formatDateTime(reply.timestamp)}</span>
                            </div>
                            <div class="mt-1">${this.formatCommentText(reply.text)}</div>
                            ${reply.image ? `<img src="${reply.image}" class="mt-2 max-h-32 rounded cursor-pointer hover:opacity-80" onclick="window.app.openImageViewer('${reply.image}', 'Reply Image')">` : ''}
                            <div class="flex gap-2 mt-1">
                                <button onclick="window.app.showReplyModal('${postId}', ${commentIndex}, ${replyIndex}, '${reply.user}')" 
                                        class="text-xs text-blue-400 hover:text-blue-300">Reply</button>
                                ${canDeleteReply ? `
                                <button onclick="window.app.deleteReply('${postId}', ${commentIndex}, ${reply.timestamp})" 
                                        class="text-xs text-red-400 hover:text-red-300">Delete</button>
                                ` : ''}
                            </div>
                            ${showRepliesBtn}
                            ${nestedHtml ? `<div class="ml-4 mt-2 pl-3 border-l-2 border-gray-700 space-y-2">${nestedHtml}</div>` : ''}
                        </div>
                    `;
                }).join('');
                
                if (depth === 0) {
                    return `
                        <div class="ml-4 mt-2 pl-3 border-l-2 border-gray-700 space-y-2">
                            ${childrenHtml}
                        </div>
                    `;
                }
                
                return childrenHtml;
            },

            // Helper to count nested replies for display
            countNestedReplies(replies, parentIndex) {
                const children = replies.filter(r => r.parentReplyIndex === parentIndex);
                let count = children.length;
                children.forEach(child => {
                    const childIndex = replies.findIndex(r => r.timestamp === child.timestamp && r.user === child.user);
                    if (childIndex !== -1) {
                        count += this.countNestedReplies(replies, childIndex);
                    }
                });
                return count;
            },

            // ==========================================
            // POSTS RENDERING - FIXED SINGLE COLUMN
            // ==========================================
            
            renderPosts() {
                const container = document.getElementById('postsContainer');
                if (!container) return;
                
                container.innerHTML = '';

                let filtered = [...this.data.posts];

                if (this.data.currentTab === 'top') {
                    filtered = filtered.filter(p => p.type === 'top');
                }

                if (this.data.currentTab === 'all' && this.data.currentCategory !== 'All') {
                    filtered = filtered.filter(p => p.category === this.data.currentCategory);
                }

                if (this.data.searchQuery) {
                    filtered = filtered.filter(p => 
                        p.title?.toLowerCase().includes(this.data.searchQuery) || 
                        p.content?.toLowerCase().includes(this.data.searchQuery)
                    );
                }

                if (filtered.length === 0) {
                    container.innerHTML = `
                        <div class="text-center py-12">
                            <div class="text-gray-500 mb-4">No posts found</div>
                            ${this.data.currentUser ? `
                            <button onclick="window.app.navigate('create')" class="bg-green-600 text-black px-6 py-2 rounded-lg font-bold hover:bg-green-500 transition-colors">
                                Create First Post
                            </button>` : '<p class="text-sm text-gray-600">Login to create posts</p>'}
                        </div>
                    `;
                    return;
                }

                filtered.forEach(post => {
                    const isAdmin = this.admins.includes(this.data.currentUser?.email);
                    const isAuthor = this.data.currentUser && this.data.currentUser.email === post.author;
                    const canDelete = isAdmin || isAuthor;
                    
                    let userLikeStatus = 'none';
                    if (this.data.currentUser) {
                        if (post.likesList?.includes(this.data.currentUser.email)) userLikeStatus = 'like';
                        if (post.dislikesList?.includes(this.data.currentUser.email)) userLikeStatus = 'dislike';
                    }

                    const card = document.createElement('div');
                    card.className = 'glass-panel rounded-xl overflow-hidden border border-gray-800 hover:border-green-500/50 transition-all duration-300 w-full mb-6';
                    card.setAttribute('data-post-id', post.id);
                    
                    const commentsHtml = this.renderCommentsSection(post, isAdmin);
                    
                    const imageHtml = post.image ? `
                        <div class="w-full overflow-hidden relative group cursor-pointer bg-gray-800" onclick="window.app.openImageViewer('${post.image}', '${post.title.replace(/'/g, "\\'")}')">
                            <img src="${post.image}" 
                                 class="w-full h-auto max-h-96 object-contain mx-auto transition-transform duration-500 group-hover:scale-105" 
                                 onerror="this.onerror=null; this.parentElement.style.display='none';"
                                 loading="lazy">
                            <div class="absolute inset-0 bg-black/0 group-hover:bg-black/20 transition-colors flex items-center justify-center">
                                <i class="fa-solid fa-expand text-white opacity-0 group-hover:opacity-100 text-3xl transition-opacity"></i>
                            </div>
                            <div class="absolute top-2 right-2 bg-black/70 backdrop-blur px-2 py-1 rounded text-xs font-bold text-green-400 border border-green-500/30 pointer-events-none">
                                ${post.category}
                            </div>
                            ${post.type === 'top' ? `<div class="absolute top-2 left-2 bg-pink-600 text-white px-2 py-1 rounded text-xs font-bold shadow-lg shadow-pink-500/20 pointer-events-none"><i class="fa-solid fa-crown"></i> TOP</div>` : ''}
                        </div>
                    ` : '';
                    
                    card.innerHTML = `
                        ${imageHtml}
                        
                        <div class="p-5">
                            <div class="flex justify-between items-start mb-2">
                                <h3 class="text-xl font-bold text-white leading-tight hover:text-green-400 cursor-pointer" 
                                    onclick="window.app.navigate('profile', '${post.author}')">${post.title}</h3>
                            </div>
                            
                            <div class="flex items-center gap-2 mb-3 text-xs text-gray-400">
                                <span class="text-green-400 font-mono cursor-pointer hover:underline" 
                                      onclick="window.app.navigate('profile', '${post.author}')">@${post.authorTag}</span>
                                <span>•</span>
                                <span>${this.formatDateTime(post.timestamp)}</span>
                            </div>

                            <p class="text-gray-300 text-sm mb-4">${post.content}</p>
                            
                            <div class="flex items-center justify-between pt-4 border-t border-gray-800">
                                <div class="flex gap-4">
                                    <button onclick="event.stopPropagation(); window.app.handleVote('${post.id}', 'like')" 
                                            class="flex items-center gap-1 text-sm ${userLikeStatus === 'like' ? 'text-green-400' : 'text-gray-500 hover:text-green-400'} transition-colors">
                                        <i class="fa-solid fa-arrow-up"></i> ${post.likes || 0}
                                    </button>
                                    <button onclick="event.stopPropagation(); window.app.handleVote('${post.id}', 'dislike')" 
                                            class="flex items-center gap-1 text-sm ${userLikeStatus === 'dislike' ? 'text-red-400' : 'text-gray-500 hover:text-red-400'} transition-colors">
                                        <i class="fa-solid fa-arrow-down"></i> ${post.dislikes || 0}
                                    </button>
                                    <button onclick="event.stopPropagation(); window.app.showCommentModal('${post.id}')" 
                                            class="flex items-center gap-1 text-sm text-gray-500 hover:text-blue-400 transition-colors">
                                        <i class="fa-solid fa-comment"></i> ${post.comments?.length || 0}
                                    </button>
                                </div>
                                ${canDelete ? `
                                <button onclick="event.stopPropagation(); window.app.deletePost('${post.id}')" class="text-gray-600 hover:text-red-500 transition-colors text-xs">
                                    <i class="fa-solid fa-trash"></i> Delete
                                </button>` : ''}
                            </div>
                            ${commentsHtml}
                        </div>
                    `;
                    container.appendChild(card);
                });
            },

            getUserEmailByTag(tag) {
                const user = this.data.users.find(u => u.tag === tag);
                return user ? user.email : '';
            },

            // ==========================================
            // POST ACTIONS
            // ==========================================
            
            async handleNewPostClick() {
                if (!this.data.currentUser) {
                    this.showToast('Please login to create a post', 'error');
                    this.toggleAuthModal();
                    return;
                }
                
                // Check if user is suspended
                if (await this.isUserSuspended(this.data.currentUser.email)) {
                    this.showToast('Your account is suspended. You cannot create posts.', 'error');
                    return;
                }
                
                const userDoc = await db.collection('users').doc(this.data.currentUser.email).get();
                const userData = userDoc.data();
                const today = new Date().toDateString();
                
                if (!this.admins.includes(this.data.currentUser.email)) {
                    if (userData.lastPostDate === today && userData.postsToday >= 3) {
                        this.showToast('Daily post limit reached (3/3)', 'error');
                        return;
                    }
                }

                this.navigate('create');
            },

            async isUserSuspended(email) {
                const userDoc = await db.collection('users').doc(email).get();
                if (!userDoc.exists) return false;
                const userData = userDoc.data();
                if (!userData.suspended || !userData.suspended.until) return false;
                return Date.now() < userData.suspended.until;
            },

            getRemainingSuspensionTime(email) {
                const user = this.data.users.find(u => u.email === email);
                if (!user || !user.suspended || !user.suspended.until) return null;
                const remaining = user.suspended.until - Date.now();
                if (remaining <= 0) return null;
                
                const days = Math.floor(remaining / (24 * 60 * 60 * 1000));
                const hours = Math.floor((remaining % (24 * 60 * 60 * 1000)) / (60 * 60 * 1000));
                const minutes = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
                
                return { days, hours, minutes, total: remaining };
            },

            async submitPost(e) {
                e.preventDefault();
                
                // Prevent double submission
                if (this.data.submittingPost) return;
                this.data.submittingPost = true;
                
                const form = e.target;
                const submitBtn = form.querySelector('button[type="submit"]');
                const originalText = submitBtn.innerText;
                submitBtn.innerText = 'Publishing...';
                submitBtn.disabled = true;
                
                try {
                    if (!this.data.currentUser) {
                        this.showToast('Please login first', 'error');
                        return;
                    }

                    // Check suspension
                    if (await this.isUserSuspended(this.data.currentUser.email)) {
                        this.showToast('Your account is suspended. You cannot create posts.', 'error');
                        return;
                    }

                    const userDoc = await db.collection('users').doc(this.data.currentUser.email).get();
                    const userData = userDoc.data();
                    const today = new Date().toDateString();
                    
                    if (!this.admins.includes(this.data.currentUser.email)) {
                        if (userData.lastPostDate === today && userData.postsToday >= 3) {
                            this.showToast('Daily limit reached', 'error');
                            return;
                        }
                    }

                    let postType = 'all';
                    if (this.admins.includes(this.data.currentUser.email)) {
                        const typeSelect = document.getElementById('postTypeSelect');
                        postType = typeSelect ? typeSelect.value : 'all';
                    }

                    const newPost = {
                        title: form.title.value,
                        content: form.content.value,
                        category: form.category.value,
                        image: form.imageUrl.value || '',
                        author: this.data.currentUser.email,
                        authorTag: this.data.currentUser.tag,
                        likes: 0,
                        dislikes: 0,
                        likesList: [],
                        dislikesList: [],
                        comments: [],
                        timestamp: Date.now(),
                        type: postType
                    };

                    await db.collection('posts').add(newPost);
                    
                    const updates = {};
                    if (userData.lastPostDate !== today) {
                        updates.lastPostDate = today;
                        updates.postsToday = 1;
                    } else {
                        updates.postsToday = (userData.postsToday || 0) + 1;
                    }
                    await db.collection('users').doc(this.data.currentUser.email).update(updates);
                    
                    this.showToast('Post published successfully!');
                    this.navigate('home');
                    form.reset();
                } catch (error) {
                    console.error('Error creating post:', error);
                    this.showToast('Error creating post', 'error');
                } finally {
                    this.data.submittingPost = false;
                    submitBtn.innerText = originalText;
                    submitBtn.disabled = false;
                }
            },

            async deletePost(id) {
                if (!confirm('Are you sure you want to delete this post?')) return;
                
                try {
                    await db.collection('posts').doc(id).delete();
                    this.showToast('Post deleted');
                } catch (error) {
                    console.error('Error deleting post:', error);
                    this.showToast('Error deleting post', 'error');
                }
            },

            // FIXED: handleVote now uses transaction to avoid permission issues
            async handleVote(postId, type) {
                if (!this.data.currentUser) {
                    this.showToast('Login to vote', 'error');
                    return;
                }

                try {
                    const postRef = db.collection('posts').doc(postId);
                    
                    // Use transaction to ensure atomic update and avoid permission issues
                    await db.runTransaction(async (transaction) => {
                        const postDoc = await transaction.get(postRef);
                        
                        if (!postDoc.exists) {
                            throw new Error('Post not found');
                        }
                        
                        const post = postDoc.data();
                        const userEmail = this.data.currentUser.email;

                        const likesList = post.likesList || [];
                        const dislikesList = post.dislikesList || [];
                        
                        const hasLiked = likesList.includes(userEmail);
                        const hasDisliked = dislikesList.includes(userEmail);

                        const updates = {};

                        if (type === 'like') {
                            if (hasLiked) {
                                // Remove like
                                updates.likesList = likesList.filter(e => e !== userEmail);
                                updates.likes = Math.max((post.likes || 0) - 1, 0);
                            } else {
                                // Add like
                                updates.likesList = [...likesList, userEmail];
                                updates.likes = (post.likes || 0) + 1;
                                // Remove dislike if exists
                                if (hasDisliked) {
                                    updates.dislikesList = dislikesList.filter(e => e !== userEmail);
                                    updates.dislikes = Math.max((post.dislikes || 0) - 1, 0);
                                }
                            }
                        } else if (type === 'dislike') {
                            if (hasDisliked) {
                                // Remove dislike
                                updates.dislikesList = dislikesList.filter(e => e !== userEmail);
                                updates.dislikes = Math.max((post.dislikes || 0) - 1, 0);
                            } else {
                                // Add dislike
                                updates.dislikesList = [...dislikesList, userEmail];
                                updates.dislikes = (post.dislikes || 0) + 1;
                                // Remove like if exists
                                if (hasLiked) {
                                    updates.likesList = likesList.filter(e => e !== userEmail);
                                    updates.likes = Math.max((post.likes || 0) - 1, 0);
                                }
                            }
                        }

                        transaction.update(postRef, updates);
                    });
                    
                    // No need to manually refresh - the listener will update the UI
                } catch (error) {
                    console.error('Error voting:', error);
                    this.showToast('Error voting: ' + error.message, 'error');
                }
            },

            // ==========================================
            // COMMENTS & REPLIES
            // ==========================================
            
            showCommentModal(postId) {
                if (!this.data.currentUser) {
                    this.showToast('Please login to comment', 'error');
                    this.toggleAuthModal();
                    return;
                }
                
                // Check suspension
                this.isUserSuspended(this.data.currentUser.email).then(isSuspended => {
                    if (isSuspended) {
                        this.showToast('Your account is suspended. You cannot comment.', 'error');
                        return;
                    }
                    
                    const modal = document.getElementById('commentModal');
                    const input = document.getElementById('commentInput');
                    const imageInput = document.getElementById('commentImageInput');
                    const submitBtn = document.getElementById('submitCommentBtn');
                    
                    if (modal && input && submitBtn) {
                        modal.classList.remove('hidden');
                        input.value = '';
                        if (imageInput) imageInput.value = '';
                        input.focus();
                        submitBtn.onclick = () => this.submitComment(postId);
                    }
                });
            },

            closeCommentModal() {
                const modal = document.getElementById('commentModal');
                if (modal) modal.classList.add('hidden');
            },

            async submitComment(postId) {
                // Prevent double submission
                if (this.data.submittingComment) return;
                this.data.submittingComment = true;
                
                const input = document.getElementById('commentInput');
                const imageInput = document.getElementById('commentImageInput');
                const submitBtn = document.getElementById('submitCommentBtn');
                const text = input?.value.trim();
                const image = imageInput?.value.trim() || '';
                
                if (!text) {
                    this.showToast('Please enter a comment', 'error');
                    this.data.submittingComment = false;
                    return;
                }
                
                submitBtn.innerText = 'Posting...';
                submitBtn.disabled = true;
                
                try {
                    const postRef = db.collection('posts').doc(postId);
                    
                    // Use transaction to safely update comments
                    await db.runTransaction(async (transaction) => {
                        const postDoc = await transaction.get(postRef);
                        
                        if (!postDoc.exists) {
                            throw new Error('Post not found');
                        }
                        
                        const comments = postDoc.data().comments || [];
                        const newComment = {
                            user: this.data.currentUser.tag,
                            text: text,
                            image: image,
                            timestamp: Date.now(),
                            replies: []
                        };
                        comments.push(newComment);
                        transaction.update(postRef, { comments: comments });
                    });
                    
                    // Process mentions for notifications
                    const mentions = text.match(/@(\w+)/g);
                    if (mentions) {
                        for (const mention of mentions) {
                            const tag = mention.substring(1);
                            const mentionedUser = this.data.users.find(u => u.tag === tag);
                            if (mentionedUser && mentionedUser.email !== this.data.currentUser.email) {
                                await this.createNotification(mentionedUser.email, postId, this.data.currentUser.tag, 'mention', comments.length - 1);
                            }
                        }
                    }
                    
                    this.closeCommentModal();
                    this.showToast('Comment added!');
                } catch (error) {
                    console.error('Error adding comment:', error);
                    this.showToast('Error adding comment: ' + error.message, 'error');
                } finally {
                    this.data.submittingComment = false;
                    submitBtn.innerText = 'Post Comment';
                    submitBtn.disabled = false;
                }
            },

            async deleteComment(postId, commentIndex) {
                if (!confirm('Are you sure you want to delete this comment?')) return;
                
                try {
                    const postRef = db.collection('posts').doc(postId);
                    
                    await db.runTransaction(async (transaction) => {
                        const postDoc = await transaction.get(postRef);
                        
                        if (!postDoc.exists) return;
                        
                        const comments = postDoc.data().comments || [];
                        comments.splice(commentIndex, 1);
                        
                        transaction.update(postRef, { comments: comments });
                    });
                    
                    this.showToast('Comment deleted');
                } catch (error) {
                    console.error('Error deleting comment:', error);
                    this.showToast('Error deleting comment', 'error');
                }
            },

            // FIXED: showReplyModal now correctly passes the parentReplyIndex
            showReplyModal(postId, commentIndex, replyIndex, replyToUser) {
                if (!this.data.currentUser) {
                    this.showToast('Please login to reply', 'error');
                    this.toggleAuthModal();
                    return;
                }
                
                // Check suspension
                this.isUserSuspended(this.data.currentUser.email).then(isSuspended => {
                    if (isSuspended) {
                        this.showToast('Your account is suspended. You cannot reply.', 'error');
                        return;
                    }
                    
                    const modal = document.getElementById('replyModal');
                    const input = document.getElementById('replyInput');
                    const imageInput = document.getElementById('replyImageInput');
                    const submitBtn = document.getElementById('submitReplyBtn');
                    
                    if (modal && input && submitBtn) {
                        modal.classList.remove('hidden');
                        input.value = `@${replyToUser} `;
                        if (imageInput) imageInput.value = '';
                        input.focus();
                        // FIXED: Store the correct parentReplyIndex
                        // If replyIndex is null, this is a reply to the comment itself
                        // If replyIndex is a number, this is a reply to that specific reply
                        modal.setAttribute('data-parent-reply-index', replyIndex !== null && replyIndex !== undefined ? replyIndex : '');
                        submitBtn.onclick = () => this.submitReply(postId, commentIndex, replyIndex, replyToUser);
                    }
                });
            },

            closeReplyModal() {
                const modal = document.getElementById('replyModal');
                if (modal) {
                    modal.classList.add('hidden');
                    modal.removeAttribute('data-parent-reply-index');
                }
            },

            // FIXED: submitReply now correctly handles parentReplyIndex for proper threading
            async submitReply(postId, commentIndex, parentReplyIndex, replyToUser) {
                // Prevent double submission
                if (this.data.submittingReply) return;
                this.data.submittingReply = true;
                
                const input = document.getElementById('replyInput');
                const imageInput = document.getElementById('replyImageInput');
                const submitBtn = document.getElementById('submitReplyBtn');
                const text = input?.value.trim();
                const image = imageInput?.value.trim() || '';
                
                if (!text) {
                    this.showToast('Please enter a reply', 'error');
                    this.data.submittingReply = false;
                    return;
                }
                
                submitBtn.innerText = 'Posting...';
                submitBtn.disabled = true;
                
                try {
                    const postRef = db.collection('posts').doc(postId);
                    
                    // Use transaction for atomic update
                    await db.runTransaction(async (transaction) => {
                        const postDoc = await transaction.get(postRef);
                        
                        if (!postDoc.exists) {
                            throw new Error('Post not found');
                        }
                        
                        const post = postDoc.data();
                        const comments = post.comments || [];
                        
                        if (!comments[commentIndex]) {
                            throw new Error('Comment not found');
                        }
                        
                        if (!comments[commentIndex].replies) {
                            comments[commentIndex].replies = [];
                        }
                        
                        // FIXED: Create reply with correct parentReplyIndex
                        // parentReplyIndex should be:
                        // - null if replying directly to the comment
                        // - the index of the reply being replied to (within the replies array)
                        const newReply = {
                            user: this.data.currentUser.tag,
                            text: text,
                            image: image,
                            timestamp: Date.now(),
                            // FIXED: Store the correct parent index
                            parentReplyIndex: parentReplyIndex !== null && parentReplyIndex !== undefined ? parentReplyIndex : null
                        };
                        
                        comments[commentIndex].replies.push(newReply);
                        transaction.update(postRef, { comments: comments });
                    });
                    
                    // Get the updated comment to find the new reply index for notification
                    const updatedPost = await postRef.get();
                    const updatedComments = updatedPost.data().comments || [];
                    const newReplyIndex = (updatedComments[commentIndex]?.replies?.length || 1) - 1;
                    
                    // Process mentions for notifications
                    const mentions = text.match(/@(\w+)/g);
                    if (mentions) {
                        for (const mention of mentions) {
                            const tag = mention.substring(1);
                            const mentionedUser = this.data.users.find(u => u.tag === tag);
                            if (mentionedUser && mentionedUser.email !== this.data.currentUser.email) {
                                await this.createNotification(mentionedUser.email, postId, this.data.currentUser.tag, 'reply', commentIndex, newReplyIndex);
                            }
                        }
                    }
                    
                    this.closeReplyModal();
                    this.showToast('Reply added!');
                } catch (error) {
                    console.error('Error adding reply:', error);
                    this.showToast('Error adding reply: ' + error.message, 'error');
                } finally {
                    this.data.submittingReply = false;
                    submitBtn.innerText = 'Post Reply';
                    submitBtn.disabled = false;
                }
            },

            async deleteReply(postId, commentIndex, replyTimestamp) {
                if (!confirm('Are you sure you want to delete this reply?')) return;
                
                try {
                    const postRef = db.collection('posts').doc(postId);
                    
                    await db.runTransaction(async (transaction) => {
                        const postDoc = await transaction.get(postRef);
                        
                        if (!postDoc.exists) return;
                        
                        const comments = postDoc.data().comments || [];
                        if (!comments[commentIndex] || !comments[commentIndex].replies) return;
                        
                        // Find the reply with matching timestamp
                        const replyIndex = comments[commentIndex].replies.findIndex(r => r.timestamp === replyTimestamp);
                        if (replyIndex === -1) return;
                        
                        // Build a map of all replies and their children
                        const replies = comments[commentIndex].replies;
                        const childrenMap = new Map();
                        
                        replies.forEach((r, idx) => {
                            const parentIdx = r.parentReplyIndex;
                            if (parentIdx !== null && parentIdx !== undefined) {
                                if (!childrenMap.has(parentIdx)) {
                                    childrenMap.set(parentIdx, []);
                                }
                                childrenMap.get(parentIdx).push(idx);
                            }
                        });
                        
                        // Collect all indices to delete (this reply and all its descendants)
                        const indicesToDelete = [];
                        const collectDescendants = (idx) => {
                            indicesToDelete.push(idx);
                            const children = childrenMap.get(idx) || [];
                            children.forEach(childIdx => collectDescendants(childIdx));
                        };
                        
                        collectDescendants(replyIndex);
                        
                        // Sort in descending order to delete from end to start
                        indicesToDelete.sort((a, b) => b - a);
                        
                        // Delete all collected replies
                        indicesToDelete.forEach(idx => {
                            comments[commentIndex].replies.splice(idx, 1);
                        });
                        
                        // Rebuild parentReplyIndex for remaining replies
                        const oldToNewMap = new Map();
                        let newIndex = 0;
                        replies.forEach((r, oldIdx) => {
                            if (!indicesToDelete.includes(oldIdx)) {
                                oldToNewMap.set(oldIdx, newIndex++);
                            }
                        });
                        
                        comments[commentIndex].replies.forEach(r => {
                            if (r.parentReplyIndex !== null && r.parentReplyIndex !== undefined) {
                                // Map old parent index to new parent index
                                const newParentIdx = oldToNewMap.get(r.parentReplyIndex);
                                r.parentReplyIndex = newParentIdx !== undefined ? newParentIdx : null;
                            }
                        });
                        
                        transaction.update(postRef, { comments: comments });
                    });
                    
                    this.showToast('Reply deleted');
                } catch (error) {
                    console.error('Error deleting reply:', error);
                    this.showToast('Error deleting reply', 'error');
                }
            },

            async createNotification(targetEmail, postId, fromUser, type = 'mention', commentIndex = null, replyIndex = null) {
                try {
                    await db.collection('notifications').add({
                        targetUser: targetEmail,
                        postId: postId,
                        fromUser: fromUser,
                        type: type,
                        timestamp: Date.now(),
                        read: false,
                        commentIndex: commentIndex,
                        replyIndex: replyIndex
                    });
                } catch (error) {
                    console.error('Error creating notification:', error);
                }
            },

            // ==========================================
            // NOTIFICATIONS
            // ==========================================
            
            renderNotifications() {
                const container = document.getElementById('notificationsList');
                if (!container) return;
                
                container.innerHTML = '<div class="text-center text-gray-500 py-8">Loading notifications...</div>';
                
                const twentyFourHoursAgo = Date.now() - (24 * 60 * 60 * 1000);
                
                db.collection('notifications')
                    .where('targetUser', '==', this.data.currentUser.email)
                    .get()
                    .then((snapshot) => {
                        const notifications = [];
                        snapshot.forEach((doc) => {
                            const data = doc.data();
                            if (data.timestamp > twentyFourHoursAgo) {
                                notifications.push({ id: doc.id, ...data });
                            }
                        });
                        
                        notifications.sort((a, b) => b.timestamp - a.timestamp);
                        
                        if (notifications.length === 0) {
                            container.innerHTML = '<div class="text-center text-gray-500 py-8">No new notifications</div>';
                            return;
                        }
                        
                        container.innerHTML = notifications.map(notif => {
                            const post = this.data.posts.find(p => p.id === notif.postId);
                            const hoursLeft = Math.ceil((24 * 60 * 60 * 1000 - (Date.now() - notif.timestamp)) / (60 * 60 * 1000));
                            const typeText = notif.type === 'reply' ? 'replied to you' : 'mentioned you';
                            
                            return `
                                <div class="p-4 bg-gray-800 rounded-lg mb-3 cursor-pointer hover:bg-gray-700 transition-colors" 
                                     onclick="window.app.goToNotification('${notif.postId}', ${notif.commentIndex}, ${notif.replyIndex})">
                                    <div class="flex items-center gap-3">
                                        <div class="w-10 h-10 rounded-full bg-green-600 flex items-center justify-center flex-shrink-0">
                                            <i class="fa-solid fa-at text-white"></i>
                                        </div>
                                        <div class="flex-grow min-w-0">
                                            <p class="text-white text-sm truncate">
                                                <span class="text-green-400 font-bold">@${notif.fromUser}</span> ${typeText}
                                            </p>
                                            <p class="text-gray-500 text-xs mt-1 truncate">
                                                ${post ? `on "${post.title}"` : 'in a comment'}
                                            </p>
                                        </div>
                                        <div class="text-xs text-gray-600 flex-shrink-0">
                                            ${hoursLeft}h
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('');
                    })
                    .catch((error) => {
                        console.error('Error loading notifications:', error);
                        container.innerHTML = `<div class="text-center text-gray-500 py-8">Error loading notifications<br><span class="text-xs">${error.message}</span></div>`;
                    });
            },

            goToNotification(postId, commentIndex, replyIndex) {
                this.data.highlightedComment = commentIndex;
                this.data.highlightedReply = replyIndex;
                
                // If it's a reply, we need to expand the comment and reply
                if (commentIndex !== null) {
                    this.data.expandedComments.add(postId);
                    if (replyIndex !== null) {
                        const commentId = `comment-${postId}-${commentIndex}`;
                        this.data.expandedReplies.add(commentId);
                    }
                }
                
                this.navigate('home');
                setTimeout(() => {
                    const postElement = document.querySelector(`[data-post-id="${postId}"]`);
                    if (postElement) {
                        postElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        postElement.classList.add('ring-2', 'ring-green-500');
                        setTimeout(() => postElement.classList.remove('ring-2', 'ring-green-500'), 2000);
                        
                        // Scroll to specific comment if provided
                        if (commentIndex !== null) {
                            const commentId = `comment-${postId}-${commentIndex}`;
                            const commentElement = document.getElementById(commentId);
                            if (commentElement) {
                                setTimeout(() => {
                                    commentElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }, 500);
                            }
                        }
                    }
                }, 500);
            },

            // ==========================================
            // MESSAGING SYSTEM - FIXED VERSION
            // ==========================================
            
            async startMessage(targetEmail) {
                console.log('Starting message with:', targetEmail);
                
                if (!this.data.currentUser) {
                    this.showToast('Please login to send messages', 'error');
                    this.toggleAuthModal();
                    return;
                }
                
                if (targetEmail === this.data.currentUser.email) {
                    this.showToast('Cannot message yourself', 'error');
                    return;
                }
                
                // Check if user is suspended
                if (await this.isUserSuspended(this.data.currentUser.email)) {
                    this.showToast('Your account is suspended. You cannot send messages.', 'error');
                    return;
                }
                
                const conversationId = this.getConversationId(this.data.currentUser.email, targetEmail);
                
                try {
                    const conversationDoc = await db.collection('conversations').doc(conversationId).get();
                    
                    if (conversationDoc.exists) {
                        const data = conversationDoc.data();
                        // Check if blocked
                        if (data.blocked && (data.blockedBy === this.data.currentUser.email || data.blockedBy === targetEmail)) {
                            this.showToast('Cannot message this user. Conversation is blocked.', 'error');
                            return;
                        }
                        // If conversation exists and accepted, go to chat
                        if (data.status === 'accepted') {
                            this.navigate('chat', { conversationId, otherUser: targetEmail });
                            return;
                        }
                    }
                    
                    // Check if they follow each other
                    const currentUserData = this.data.users.find(u => u.email === this.data.currentUser.email);
                    const targetUserData = this.data.users.find(u => u.email === targetEmail);
                    
                    const currentFollowsTarget = currentUserData?.following?.includes(targetEmail);
                    const targetFollowsCurrent = targetUserData?.following?.includes(this.data.currentUser.email);
                    
                    if (currentFollowsTarget && targetFollowsCurrent) {
                        // Mutual follow - create conversation if not exists or show chat
                        if (!conversationDoc.exists) {
                            await this.createConversation(targetEmail, 'accepted');
                        } else if (conversationDoc.data().status === 'pending') {
                            await db.collection('conversations').doc(conversationId).update({ status: 'accepted' });
                        }
                        this.navigate('chat', { conversationId, otherUser: targetEmail });
                    } else {
                        // Show message request modal
                        this.showMessageRequestModal(targetEmail);
                    }
                } catch (error) {
                    console.error('Error starting message:', error);
                    this.showToast('Error starting conversation: ' + (error.message || 'Unknown error'), 'error');
                }
            },
            
            getConversationId(email1, email2) {
                return [email1, email2].sort().join('_');
            },
            
            async createConversation(targetEmail, status = 'pending') {
                const conversationId = this.getConversationId(this.data.currentUser.email, targetEmail);
                
                await db.collection('conversations').doc(conversationId).set({
                    participants: [this.data.currentUser.email, targetEmail],
                    createdAt: Date.now(),
                    status: status,
                    lastMessage: null,
                    lastMessageAt: Date.now(),
                    initiatedBy: this.data.currentUser.email,
                    blocked: false,
                    blockedBy: null
                });
                
                return conversationId;
            },
            
            showMessageRequestModal(targetEmail) {
                const modal = document.getElementById('messageRequestModal');
                const input = document.getElementById('messageRequestInput');
                const imageInput = document.getElementById('messageRequestImageInput');
                const submitBtn = document.getElementById('sendMessageRequestBtn');
                
                if (modal && input && submitBtn) {
                    modal.classList.remove('hidden');
                    modal.setAttribute('data-target-email', targetEmail);
                    input.value = '';
                    if (imageInput) imageInput.value = '';
                    input.focus();
                    submitBtn.onclick = () => this.sendMessageRequest(targetEmail);
                }
            },
            
            closeMessageRequestModal() {
                const modal = document.getElementById('messageRequestModal');
                if (modal) {
                    modal.classList.add('hidden');
                    modal.removeAttribute('data-target-email');
                }
            },
            
            async sendMessageRequest(targetEmail) {
                const input = document.getElementById('messageRequestInput');
                const imageInput = document.getElementById('messageRequestImageInput');
                const submitBtn = document.getElementById('sendMessageRequestBtn');
                
                const text = input?.value.trim();
                const image = imageInput?.value.trim() || '';
                
                if (!text) {
                    this.showToast('Please enter a message', 'error');
                    return;
                }
                
                submitBtn.innerText = 'Sending...';
                submitBtn.disabled = true;
                
                try {
                    const conversationId = this.getConversationId(this.data.currentUser.email, targetEmail);
                    
                    // Create conversation with pending status
                    await this.createConversation(targetEmail, 'pending');
                    
                    // Add first message
                    await db.collection('conversations').doc(conversationId).collection('messages').add({
                        text: text,
                        image: image,
                        sender: this.data.currentUser.email,
                        timestamp: Date.now(),
                        read: false
                    });
                    
                    // Update conversation
                    await db.collection('conversations').doc(conversationId).update({
                        lastMessage: text,
                        lastMessageAt: Date.now()
                    });
                    
                    this.closeMessageRequestModal();
                    this.showToast('Message request sent! Waiting for acceptance.');
                    this.navigate('messages');
                } catch (error) {
                    console.error('Error sending message request:', error);
                    this.showToast('Error sending message request: ' + error.message, 'error');
                } finally {
                    submitBtn.innerText = 'Send Message';
                    submitBtn.disabled = false;
                }
            },
            
            async renderMessagesList() {
                const container = document.getElementById('messagesListContainer');
                if (!container) return;
                
                if (!this.data.currentUser) {
                    container.innerHTML = '<div class="text-center text-gray-500 py-8">Please login to view messages</div>';
                    return;
                }
                
                try {
                    // Use get() instead of onSnapshot to avoid permission issues initially
                    const snapshot = await db.collection('conversations')
                        .where('participants', 'array-contains', this.data.currentUser.email)
                        .get();
                    
                    const conversations = [];
                    snapshot.forEach(doc => {
                        const data = doc.data();
                        conversations.push({ id: doc.id, ...data });
                    });
                    
                    // Sort manually by lastMessageAt
                    conversations.sort((a, b) => (b.lastMessageAt || 0) - (a.lastMessageAt || 0));
                    
                    if (conversations.length === 0) {
                        container.innerHTML = '<div class="text-center text-gray-500 py-8">No conversations yet</div>';
                        return;
                    }
                    
                    container.innerHTML = conversations.map(conv => {
                        const otherUserEmail = conv.participants.find(p => p !== this.data.currentUser.email);
                        const otherUser = this.data.users.find(u => u.email === otherUserEmail);
                        const isPending = conv.status === 'pending';
                        const isInitiator = conv.initiatedBy === this.data.currentUser.email;
                        const isBlocked = conv.blocked;
                        
                        let statusBadge = '';
                        if (isBlocked) {
                            statusBadge = '<span class="text-xs text-red-400 ml-2">Blocked</span>';
                        } else if (isPending) {
                            if (isInitiator) {
                                statusBadge = '<span class="text-xs text-yellow-400 ml-2">Pending</span>';
                            } else {
                                statusBadge = '<span class="text-xs text-blue-400 ml-2">New Request</span>';
                            }
                        }
                        
                        return `
                            <div class="flex items-center justify-between p-4 bg-gray-800 rounded-lg mb-3 cursor-pointer hover:bg-gray-700 transition-colors" 
                                 onclick="window.app.handleConversationClick('${conv.id}', '${otherUserEmail}')">
                                <div class="flex items-center gap-3">
                                    <img src="${otherUser?.pic || `https://ui-avatars.com/api/?name=${encodeURIComponent(otherUser?.displayName || otherUser?.tag || 'User')}&background=10b981&color=fff&size=64`}" 
                                         class="w-12 h-12 rounded-full object-cover">
                                    <div>
                                        <div class="text-white font-bold flex items-center">
                                            ${otherUser?.displayName || otherUser?.tag || 'Unknown'}
                                            ${statusBadge}
                                        </div>
                                        <div class="text-xs text-gray-400 truncate max-w-xs">
                                            ${isPending && !isInitiator ? 'Message request - click to accept or reject' : (conv.lastMessage || 'No messages yet')}
                                        </div>
                                    </div>
                                </div>
                                <div class="text-xs text-gray-500">
                                    ${conv.lastMessageAt ? this.formatDateTime(conv.lastMessageAt) : ''}
                                </div>
                            </div>
                        `;
                    }).join('');
                } catch (error) {
                    console.error('Error loading messages:', error);
                    container.innerHTML = `<div class="text-center text-gray-500 py-8">Error loading messages<br><span class="text-xs">${error.message}</span></div>`;
                }
            },
            
            async handleConversationClick(conversationId, otherUserEmail) {
                try {
                    const conversationDoc = await db.collection('conversations').doc(conversationId).get();
                    if (!conversationDoc.exists) return;
                    
                    const data = conversationDoc.data();
                    
                    if (data.status === 'pending') {
                        if (data.initiatedBy === this.data.currentUser.email) {
                            // Show pending modal for initiator
                            this.showPendingRequestModal(otherUserEmail);
                        } else {
                            // Show accept/reject modal for receiver
                            this.showAcceptRejectModal(conversationId, otherUserEmail);
                        }
                    } else if (data.blocked) {
                        this.showToast('This conversation is blocked', 'error');
                    } else {
                        this.navigate('chat', { conversationId, otherUser: otherUserEmail });
                    }
                } catch (error) {
                    console.error('Error handling conversation click:', error);
                }
            },
            
            showPendingRequestModal(otherUserEmail) {
                const user = this.data.users.find(u => u.email === otherUserEmail);
                const modal = document.getElementById('pendingRequestModal');
                const text = document.getElementById('pendingRequestText');
                
                if (modal && text) {
                    text.innerHTML = `Waiting for <span class="text-green-400">@${user?.tag || 'user'}</span> to accept your message request.`;
                    modal.classList.remove('hidden');
                }
            },
            
            closePendingRequestModal() {
                const modal = document.getElementById('pendingRequestModal');
                if (modal) modal.classList.add('hidden');
            },
            
            showAcceptRejectModal(conversationId, otherUserEmail) {
                const user = this.data.users.find(u => u.email === otherUserEmail);
                const modal = document.getElementById('acceptRejectModal');
                const text = document.getElementById('acceptRejectText');
                const acceptBtn = document.getElementById('acceptRequestBtn');
                const rejectBtn = document.getElementById('rejectRequestBtn');
                
                if (modal && text && acceptBtn && rejectBtn) {
                    text.innerHTML = `<span class="text-green-400">@${user?.tag || 'user'}</span> wants to start a conversation with you.`;
                    modal.classList.remove('hidden');
                    
                    acceptBtn.onclick = () => this.acceptConversation(conversationId, otherUserEmail);
                    rejectBtn.onclick = () => this.rejectConversation(conversationId);
                }
            },
            
            closeAcceptRejectModal() {
                const modal = document.getElementById('acceptRejectModal');
                if (modal) modal.classList.add('hidden');
            },
            
            async acceptConversation(conversationId, otherUserEmail) {
                try {
                    await db.collection('conversations').doc(conversationId).update({
                        status: 'accepted'
                    });
                    this.closeAcceptRejectModal();
                    this.showToast('Conversation accepted!');
                    this.navigate('chat', { conversationId, otherUser: otherUserEmail });
                } catch (error) {
                    console.error('Error accepting conversation:', error);
                    this.showToast('Error accepting conversation', 'error');
                }
            },
            
            async rejectConversation(conversationId) {
                try {
                    // Delete the conversation and all messages
                    const messagesSnapshot = await db.collection('conversations').doc(conversationId).collection('messages').get();
                    const batch = db.batch();
                    messagesSnapshot.forEach(doc => {
                        batch.delete(doc.ref);
                    });
                    batch.delete(db.collection('conversations').doc(conversationId));
                    await batch.commit();
                    
                    this.closeAcceptRejectModal();
                    this.showToast('Conversation rejected');
                    this.renderMessagesList();
                } catch (error) {
                    console.error('Error rejecting conversation:', error);
                    this.showToast('Error rejecting conversation', 'error');
                }
            },
            
            async renderChat(chatData) {
                if (!chatData) return;
                
                const { conversationId, otherUser } = chatData;
                const container = document.getElementById('chatContainer');
                const header = document.getElementById('chatHeader');
                const messagesContainer = document.getElementById('chatMessages');
                
                if (!container || !header || !messagesContainer) return;
                
                container.classList.remove('hidden');
                
                const otherUserData = this.data.users.find(u => u.email === otherUser);
                
                try {
                    const conversationDoc = await db.collection('conversations').doc(conversationId).get();
                    const conversationData = conversationDoc.data() || {};
                    
                    // Check if blocked
                    const isBlocked = conversationData?.blocked;
                    const blockedBy = conversationData?.blockedBy;
                    const isBlockedByMe = blockedBy === this.data.currentUser.email;
                    
                    // Render header with block/unblock button
                    header.innerHTML = `
                        <div class="flex items-center justify-between mb-4">
                            <div class="flex items-center gap-3">
                                <button onclick="window.app.navigate('messages')" class="text-gray-400 hover:text-white">
                                    <i class="fa-solid fa-arrow-left"></i>
                                </button>
                                <img src="${otherUserData?.pic || `https://ui-avatars.com/api/?name=${encodeURIComponent(otherUserData?.displayName || otherUserData?.tag || 'User')}&background=10b981&color=fff&size=64`}" 
                                     class="w-10 h-10 rounded-full object-cover">
                                <div>
                                    <div class="text-white font-bold">${otherUserData?.displayName || otherUserData?.tag || 'Unknown'}</div>
                                    <div class="text-xs text-gray-400">@${otherUserData?.tag || 'unknown'}</div>
                                </div>
                            </div>
                            <button onclick="window.app.toggleBlock('${conversationId}', '${otherUser}')" 
                                    class="px-4 py-2 rounded-lg ${isBlocked ? 'bg-red-600 hover:bg-red-500' : 'bg-gray-700 hover:bg-gray-600'} text-white text-sm font-bold transition-colors">
                                ${isBlocked ? (isBlockedByMe ? 'Unblock' : 'Blocked') : 'Block'}
                            </button>
                        </div>
                    `;
                    
                    // Load messages
                    const messagesSnapshot = await db.collection('conversations').doc(conversationId)
                        .collection('messages')
                        .orderBy('timestamp', 'asc')
                        .get();
                    
                    const messages = [];
                    messagesSnapshot.forEach(doc => {
                        messages.push({ id: doc.id, ...doc.data() });
                    });
                    
                    if (messages.length === 0) {
                        messagesContainer.innerHTML = '<div class="text-center text-gray-500 py-8">No messages yet. Start the conversation!</div>';
                    } else {
                        messagesContainer.innerHTML = messages.map(msg => {
                            const isMe = msg.sender === this.data.currentUser.email;
                            return `
                                <div class="flex ${isMe ? 'justify-end' : 'justify-start'} mb-4">
                                    <div class="max-w-[70%] ${isMe ? 'bg-green-600 text-black' : 'bg-gray-700 text-white'} rounded-lg p-3">
                                        ${msg.image ? `<img src="${msg.image}" class="mb-2 max-h-48 rounded cursor-pointer" onclick="window.app.openImageViewer('${msg.image}', 'Message Image')">` : ''}
                                        <div class="text-sm">${msg.text}</div>
                                        <div class="text-xs ${isMe ? 'text-green-800' : 'text-gray-400'} mt-1 text-right">
                                            ${this.formatDateTime(msg.timestamp)}
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('');
                        
                        // Scroll to bottom
                        messagesContainer.scrollTop = messagesContainer.scrollHeight;
                    }
                    
                    // Render input area (disabled if blocked)
                    const inputContainer = document.getElementById('chatInputContainer');
                    if (inputContainer) {
                        if (isBlocked) {
                            inputContainer.innerHTML = `
                                <div class="p-4 bg-red-900/30 border border-red-500/30 rounded-lg text-center text-red-400">
                                    ${isBlockedByMe ? 'You have blocked this user. Unblock to send messages.' : 'You have been blocked by this user.'}
                                </div>
                            `;
                        } else {
                            inputContainer.innerHTML = `
                                <div class="flex gap-2">
                                    <input type="text" id="chatMessageInput" placeholder="Type a message..." 
                                           class="flex-1 bg-gray-800 border border-gray-700 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none"
                                           onkeypress="if(event.key === 'Enter') window.app.sendChatMessage('${conversationId}')">
                                    <input type="url" id="chatImageInput" placeholder="Image URL..." 
                                           class="w-32 bg-gray-800 border border-gray-700 rounded-lg p-3 text-white text-sm focus:border-green-500 focus:outline-none">
                                    <button onclick="window.app.sendChatMessage('${conversationId}')" 
                                            class="bg-green-600 hover:bg-green-500 text-black font-bold px-6 rounded-lg transition-colors">
                                        <i class="fa-solid fa-paper-plane"></i>
                                    </button>
                                </div>
                            `;
                        }
                    }
                    
                    // Mark messages as read
                    messagesSnapshot.forEach(async doc => {
                        const msg = doc.data();
                        if (msg.sender !== this.data.currentUser.email && !msg.read) {
                            await db.collection('conversations').doc(conversationId)
                                .collection('messages').doc(doc.id).update({ read: true });
                        }
                    });
                } catch (error) {
                    console.error('Error rendering chat:', error);
                    messagesContainer.innerHTML = `<div class="text-center text-gray-500 py-8">Error loading chat</div>`;
                }
            },
            
            async sendChatMessage(conversationId) {
                const input = document.getElementById('chatMessageInput');
                const imageInput = document.getElementById('chatImageInput');
                
                const text = input?.value.trim();
                const image = imageInput?.value.trim() || '';
                
                if (!text) return;
                
                try {
                    // Check suspension
                    if (await this.isUserSuspended(this.data.currentUser.email)) {
                        this.showToast('Your account is suspended. You cannot send messages.', 'error');
                        return;
                    }
                    
                    await db.collection('conversations').doc(conversationId).collection('messages').add({
                        text: text,
                        image: image,
                        sender: this.data.currentUser.email,
                        timestamp: Date.now(),
                        read: false
                    });
                    
                    await db.collection('conversations').doc(conversationId).update({
                        lastMessage: text,
                        lastMessageAt: Date.now()
                    });
                    
                    if (input) input.value = '';
                    if (imageInput) imageInput.value = '';
                    
                    // Refresh chat
                    this.renderChat(this.data.currentChat);
                } catch (error) {
                    console.error('Error sending message:', error);
                    this.showToast('Error sending message', 'error');
                }
            },
            
            async toggleBlock(conversationId, otherUser) {
                try {
                    const conversationDoc = await db.collection('conversations').doc(conversationId).get();
                    if (!conversationDoc.exists) return;
                    
                    const data = conversationDoc.data();
                    
                    if (data.blocked) {
                        if (data.blockedBy === this.data.currentUser.email) {
                            // Unblock
                            await db.collection('conversations').doc(conversationId).update({
                                blocked: false,
                                blockedBy: null
                            });
                            this.showToast('User unblocked');
                        } else {
                            this.showToast('You cannot unblock. The other user blocked you.', 'error');
                        }
                    } else {
                        // Block
                        await db.collection('conversations').doc(conversationId).update({
                            blocked: true,
                            blockedBy: this.data.currentUser.email
                        });
                        this.showToast('User blocked');
                    }
                    
                    // Refresh chat
                    this.renderChat(this.data.currentChat);
                } catch (error) {
                    console.error('Error toggling block:', error);
                    this.showToast('Error blocking/unblocking user', 'error');
                }
            },

            // ==========================================
            // ADMIN SUSPEND FUNCTIONALITY
            // ==========================================
            
            showSuspendModal(targetEmail) {
                const modal = document.getElementById('suspendModal');
                const title = document.getElementById('suspendModalTitle');
                const daysInput = document.getElementById('suspendDaysInput');
                const hoursInput = document.getElementById('suspendHoursInput');
                const submitBtn = document.getElementById('suspendSubmitBtn');
                
                const user = this.data.users.find(u => u.email === targetEmail);
                const isCurrentlySuspended = user?.suspended && user.suspended.until > Date.now();
                
                if (modal && title && daysInput && hoursInput && submitBtn) {
                    modal.classList.remove('hidden');
                    modal.setAttribute('data-target-email', targetEmail);
                    
                    if (isCurrentlySuspended) {
                        title.innerText = 'Edit Suspension';
                        submitBtn.innerText = 'Update Suspension';
                        // Pre-fill current values
                        const remaining = this.getRemainingSuspensionTime(targetEmail);
                        if (remaining) {
                            daysInput.value = remaining.days;
                            hoursInput.value = remaining.hours;
                        }
                    } else {
                        title.innerText = 'Suspend User';
                        submitBtn.innerText = 'Suspend User';
                        daysInput.value = '';
                        hoursInput.value = '';
                    }
                    
                    submitBtn.onclick = () => this.suspendUser(targetEmail);
                }
            },
            
            closeSuspendModal() {
                const modal = document.getElementById('suspendModal');
                if (modal) {
                    modal.classList.add('hidden');
                    modal.removeAttribute('data-target-email');
                }
            },
            
            async suspendUser(targetEmail) {
                const daysInput = document.getElementById('suspendDaysInput');
                const hoursInput = document.getElementById('suspendHoursInput');
                
                const days = parseInt(daysInput?.value) || 0;
                const hours = parseInt(hoursInput?.value) || 0;
                
                if (days === 0 && hours === 0) {
                    this.showToast('Please enter suspension duration', 'error');
                    return;
                }
                
                const totalMs = (days * 24 * 60 * 60 * 1000) + (hours * 60 * 60 * 1000);
                const until = Date.now() + totalMs;
                
                try {
                    await db.collection('users').doc(targetEmail).update({
                        suspended: {
                            until: until,
                            days: days,
                            hours: hours,
                            suspendedBy: this.data.currentUser.email,
                            suspendedAt: Date.now()
                        }
                    });
                    
                    this.closeSuspendModal();
                    this.showToast(`User suspended for ${days} days and ${hours} hours`);
                    this.renderProfile(targetEmail);
                } catch (error) {
                    console.error('Error suspending user:', error);
                    this.showToast('Error suspending user', 'error');
                }
            },

            // ==========================================
            // PROFILE - FIXED PROFILE PICTURE
            // ==========================================
            
            async renderProfile(targetEmail) {
                const email = targetEmail || this.data.currentUser?.email;
                
                if (!email) {
                    this.showToast('Please login to view profiles', 'error');
                    this.navigate('home');
                    return;
                }

                this.data.profileViewUser = email;

                let user = this.data.users.find(u => u.email === email);
                
                if (!user) {
                    const userDoc = await db.collection('users').doc(email).get();
                    if (!userDoc.exists) {
                        this.showToast('User not found', 'error');
                        return;
                    }
                    user = { email: email, ...userDoc.data() };
                }

                if (!user.followers) user.followers = [];
                if (!user.following) user.following = [];

                const profileName = document.getElementById('profileName');
                const profileTag = document.getElementById('profileTag');
                const profileImage = document.getElementById('profileImage');
                const profilePostsCount = document.getElementById('profilePostsCount');
                const profileFollowers = document.getElementById('profileFollowers');
                const profileFollowing = document.getElementById('profileFollowing');
                const editSection = document.getElementById('editProfileSection');
                const followBtn = document.getElementById('followBtn');
                const messageBtn = document.getElementById('messageBtn');
                const userPostsContainer = document.getElementById('userPostsContainer');
                const emailDisplay = document.getElementById('profileEmailDisplay');
                const notificationBtn = document.getElementById('notificationBtn');
                const countryDisplay = document.getElementById('profileCountryDisplay');
                const suspendBtn = document.getElementById('suspendBtn');
                const suspendCountdown = document.getElementById('suspendCountdown');

                if (profileName) profileName.innerText = user.displayName || user.tag || 'User';
                if (profileTag) profileTag.innerText = '@' + (user.tag || 'unknown');
                
                // FIXED: Profile picture rendering with better error handling
                if (profileImage) {
                    let imgUrl;
                    if (user.pic && user.pic.trim() !== '') {
                        // Use the stored URL directly without cache-busting params that might break it
                        imgUrl = user.pic;
                    } else {
                        // Generate avatar with proper encoding
                        const name = encodeURIComponent(user.displayName || user.tag || 'User');
                        imgUrl = `https://ui-avatars.com/api/?name=${name}&background=10b981&color=fff&size=128&format=png&font-size=0.4`;
                    }
                    
                    profileImage.src = imgUrl;
                    profileImage.style.opacity = '0';
                    profileImage.style.transition = 'opacity 0.3s ease';
                    
                    profileImage.onload = function() {
                        this.style.opacity = '1';
                    };
                    
                    profileImage.onerror = function() {
                        // Fallback to generated avatar on error
                        const name = encodeURIComponent(user.displayName || user.tag || 'User');
                        this.src = `https://ui-avatars.com/api/?name=${name}&background=10b981&color=fff&size=128&format=png`;
                        this.style.opacity = '1';
                    };
                }
                
                if (emailDisplay) {
                    const isOwner = this.data.currentUser?.email === email;
                    const isAdmin = this.admins.includes(this.data.currentUser?.email);
                    if (isOwner || isAdmin) {
                        emailDisplay.innerText = email;
                        emailDisplay.classList.remove('hidden');
                    } else {
                        emailDisplay.classList.add('hidden');
                    }
                }
                
                if (countryDisplay) {
                    const country = this.countries.find(c => c.code === user.country);
                    countryDisplay.innerText = country ? `📍 ${country.name}` : '';
                    countryDisplay.classList.remove('hidden');
                }
                
                const userPosts = this.data.posts.filter(p => p.author === email);
                if (profilePostsCount) profilePostsCount.innerText = userPosts.length;
                
                const followersCount = Array.isArray(user.followers) ? user.followers.length : 0;
                const followingCount = Array.isArray(user.following) ? user.following.length : 0;
                
                if (profileFollowers) profileFollowers.innerText = followersCount;
                if (profileFollowing) profileFollowing.innerText = followingCount;

                const isOwner = this.data.currentUser?.email === email;
                // Fix: Check if current user is admin by checking if their email is in admins array
                const isAdmin = this.admins.includes(this.data.currentUser?.email);
                const isAdminViewing = isAdmin && !isOwner;

                // Show suspend button only for admins viewing other users
                if (suspendBtn) {
                    if (isAdminViewing) {
                        suspendBtn.classList.remove('hidden');
                        const isSuspended = user.suspended && user.suspended.until > Date.now();
                        suspendBtn.innerText = isSuspended ? 'Edit Suspension' : 'Suspend User';
                        suspendBtn.onclick = () => this.showSuspendModal(email);
                    } else {
                        suspendBtn.classList.add('hidden');
                    }
                }

                // Show suspension countdown for suspended users (visible to self and admins)
                if (suspendCountdown) {
                    // Clear any existing interval
                    if (this.data.suspendCountdownInterval) {
                        clearInterval(this.data.suspendCountdownInterval);
                        this.data.suspendCountdownInterval = null;
                    }
                    
                    const remaining = this.getRemainingSuspensionTime(email);
                    if (remaining && (isOwner || isAdmin)) {
                        suspendCountdown.classList.remove('hidden');
                        this.updateSuspendCountdown(suspendCountdown, remaining);
                        
                        // Update countdown every second
                        this.data.suspendCountdownInterval = setInterval(() => {
                            const newRemaining = this.getRemainingSuspensionTime(email);
                            if (newRemaining) {
                                this.updateSuspendCountdown(suspendCountdown, newRemaining);
                            } else {
                                suspendCountdown.classList.add('hidden');
                                clearInterval(this.data.suspendCountdownInterval);
                                this.data.suspendCountdownInterval = null;
                                if (isAdminViewing && suspendBtn) {
                                    suspendBtn.innerText = 'Suspend User';
                                }
                                // Refresh profile to update UI
                                this.renderProfile(email);
                            }
                        }, 1000);
                    } else {
                        suspendCountdown.classList.add('hidden');
                    }
                }

                if (notificationBtn) {
                    if (isOwner) {
                        notificationBtn.classList.remove('hidden');
                    } else {
                        notificationBtn.classList.add('hidden');
                    }
                }

                if (isOwner) {
                    editSection?.classList.remove('hidden');
                    followBtn?.classList.add('hidden');
                    messageBtn?.classList.add('hidden');
                    
                    const editTagInput = document.getElementById('editTagInput');
                    const editDisplayNameInput = document.getElementById('editDisplayNameInput');
                    const editPicInput = document.getElementById('editPicInput');
                    const countrySelect = document.getElementById('countrySelect');
                    
                    if (editTagInput) editTagInput.value = user.tag || '';
                    if (editDisplayNameInput) editDisplayNameInput.value = user.displayName || user.tag || '';
                    if (editPicInput) editPicInput.value = user.pic || '';
                    
                    if (countrySelect) {
                        countrySelect.innerHTML = this.countries.map(c => 
                            `<option value="${c.code}" ${user.country === c.code ? 'selected' : ''}>${c.name}</option>`
                        ).join('');
                    }
                } else {
                    editSection?.classList.add('hidden');
                    
                    // Show message button for logged in users viewing others
                    if (this.data.currentUser && messageBtn) {
                        messageBtn.classList.remove('hidden');
                        // Fix: Bind the email correctly using closure
                        const targetEmail = email; // Capture email in closure
                        messageBtn.onclick = (function(email) {
                            return function() {
                                window.app.startMessage(email);
                            };
                        })(email);
                    } else {
                        messageBtn?.classList.add('hidden');
                    }
                    
                    if (this.data.currentUser && followBtn) {
                        followBtn.classList.remove('hidden');
                        const currentUserData = this.data.users.find(u => u.email === this.data.currentUser.email);
                        const isFollowing = currentUserData?.following?.includes(email) || false;
                        followBtn.innerText = isFollowing ? 'Unfollow' : 'Follow';
                        // Fix: Bind the email correctly using closure
                        const targetEmail = email;
                        followBtn.onclick = (function(email) {
                            return function() {
                                window.app.toggleFollow(email);
                            };
                        })(email);
                    } else {
                        followBtn?.classList.add('hidden');
                    }
                }

                if (userPostsContainer) {
                    userPostsContainer.innerHTML = '';
                    if (userPosts.length === 0) {
                        userPostsContainer.innerHTML = `<div class="col-span-full text-center text-gray-500">No posts yet.</div>`;
                    } else {
                        userPosts.forEach(post => {
                            const div = document.createElement('div');
                            div.className = 'glass-panel p-4 rounded-lg border border-gray-800 w-full mb-4';
                            div.setAttribute('data-post-id', post.id);
                            
                            const isAdmin = this.admins.includes(this.data.currentUser?.email);
                            const isAuthor = this.data.currentUser?.email === post.author;
                            const canDelete = isAdmin || isAuthor;
                            
                            let userLikeStatus = 'none';
                            if (this.data.currentUser) {
                                if (post.likesList?.includes(this.data.currentUser.email)) userLikeStatus = 'like';
                                if (post.dislikesList?.includes(this.data.currentUser.email)) userLikeStatus = 'dislike';
                            }
                            
                            // Use same comments rendering as homepage with highlight support
                            const highlightComment = this.data.highlightedComment;
                            const highlightReply = this.data.highlightedReply;
                            const commentsHtml = this.renderCommentsSection(post, isAdmin, null, highlightComment, highlightReply ? [highlightReply] : null);
                            
                            const postImageHtml = post.image ? `
                                <div class="mb-3 bg-gray-800 rounded overflow-hidden cursor-pointer" onclick="window.app.openImageViewer('${post.image}', '${post.title.replace(/'/g, "\\'")}')">
                                    <img src="${post.image}" 
                                         class="w-full h-64 object-cover hover:scale-105 transition-transform" 
                                         onerror="this.onerror=null; this.parentElement.style.display='none';"
                                         loading="lazy">
                                </div>
                            ` : '';
                            
                            div.innerHTML = `
                                ${postImageHtml}
                                <h4 class="font-bold text-white mb-1 cursor-pointer hover:text-green-400" onclick="window.app.navigate('profile', '${post.author}')">${post.title}</h4>
                                <p class="text-xs text-gray-400 mb-2">${post.category} • ${this.formatDateTime(post.timestamp)}</p>
                                <p class="text-sm text-gray-300 line-clamp-2 mb-3">${post.content}</p>
                                <div class="flex items-center justify-between pt-3 border-t border-gray-700">
                                    <div class="flex gap-3">
                                        <button onclick="window.app.handleVote('${post.id}', 'like')" 
                                                class="text-xs ${userLikeStatus === 'like' ? 'text-green-400' : 'text-gray-500 hover:text-green-400'} transition-colors">
                                            <i class="fa-solid fa-arrow-up"></i> ${post.likes || 0}
                                        </button>
                                        <button onclick="window.app.handleVote('${post.id}', 'dislike')" 
                                                class="text-xs ${userLikeStatus === 'dislike' ? 'text-red-400' : 'text-gray-500 hover:text-red-400'} transition-colors">
                                            <i class="fa-solid fa-arrow-down"></i> ${post.dislikes || 0}
                                        </button>
                                        <button onclick="window.app.showCommentModal('${post.id}')" 
                                                class="text-xs text-gray-500 hover:text-blue-400 transition-colors">
                                            <i class="fa-solid fa-comment"></i> ${post.comments?.length || 0}
                                        </button>
                                    </div>
                                    ${canDelete ? `
                                    <button onclick="window.app.deletePost('${post.id}')" class="text-gray-600 hover:text-red-500 transition-colors text-xs">
                                        <i class="fa-solid fa-trash"></i>
                                    </button>` : ''}
                                </div>
                                ${commentsHtml}
                            `;
                            userPostsContainer.appendChild(div);
                        });
                    }
                }
            },
            
            updateSuspendCountdown(element, remaining) {
                element.innerHTML = `
                    <div class="bg-red-900/30 border border-red-500/50 rounded-lg p-3 mb-4">
                        <div class="text-red-400 text-sm font-bold mb-1">
                            <i class="fa-solid fa-ban mr-2"></i>Account Suspended
                        </div>
                        <div class="text-white text-lg font-mono">
                            ${remaining.days}d ${remaining.hours}h ${remaining.minutes}m remaining
                        </div>
                        <div class="text-xs text-gray-400 mt-1">
                            You can only like, dislike, follow, and unfollow during suspension.
                        </div>
                    </div>
                `;
            },

            async saveProfile() {
                if (!this.data.currentUser) return;
                
                const editTagInput = document.getElementById('editTagInput');
                const editDisplayNameInput = document.getElementById('editDisplayNameInput');
                const editPicInput = document.getElementById('editPicInput');
                const countrySelect = document.getElementById('countrySelect');
                
                const newTag = editTagInput?.value?.trim().replace(/\s+/g, '');
                const newDisplayName = editDisplayNameInput?.value?.trim();
                const newPic = editPicInput?.value?.trim();
                const newCountry = countrySelect?.value || 'US';
                
                if (!newTag) {
                    this.showToast('Tag cannot be empty', 'error');
                    return;
                }
                
                if (!newDisplayName) {
                    this.showToast('Display name cannot be empty', 'error');
                    return;
                }

                // Check for spaces in tag
                if (editTagInput?.value?.trim().includes(' ')) {
                    this.showToast('User tag cannot contain spaces', 'error');
                    return;
                }

                const userDoc = await db.collection('users').doc(this.data.currentUser.email).get();
                const userData = userDoc.data();
                
                // Check if tag is being changed
                if (newTag !== userData.tag) {
                    // Check 30-day restriction
                    if (userData.lastTagChange) {
                        const lastChange = new Date(userData.lastTagChange);
                        const now = new Date();
                        const daysDiff = (now - lastChange) / (1000 * 60 * 60 * 24);
                        
                        if (daysDiff < 30) {
                            const daysLeft = Math.ceil(30 - daysDiff);
                            this.showToast(`You can only change your user tag once every 30 days. ${daysLeft} days remaining.`, 'error');
                            return;
                        }
                    }
                    
                    // Check if tag is unique
                    const existingUser = this.data.users.find(u => u.tag === newTag && u.email !== this.data.currentUser.email);
                    if (existingUser) {
                        this.showToast('This user tag is already taken', 'error');
                        return;
                    }
                }

                try {
                    const postsQuery = await db.collection('posts').where('author', '==', this.data.currentUser.email).get();
                    
                    const batch = db.batch();
                    
                    postsQuery.forEach(doc => {
                        batch.update(doc.ref, { authorTag: newTag });
                    });
                    
                    const updates = {
                        tag: newTag,
                        displayName: newDisplayName,
                        pic: newPic || '',
                        country: newCountry,
                        timezone: this.countries.find(c => c.code === newCountry)?.timezone || 'America/New_York'
                    };
                    
                    // Only update lastTagChange if tag actually changed
                    if (newTag !== userData.tag) {
                        updates.lastTagChange = new Date().toISOString();
                    }
                    
                    batch.update(db.collection('users').doc(this.data.currentUser.email), updates);
                    
                    await batch.commit();
                    
                    this.data.currentUser.tag = newTag;
                    this.data.currentUser.displayName = newDisplayName;
                    this.data.currentUser.pic = newPic || '';
                    this.data.currentUser.country = newCountry;
                    this.data.currentUser.timezone = updates.timezone;
                    
                    this.showToast('Profile updated!');
                    this.renderProfile(this.data.currentUser.email);
                } catch (error) {
                    console.error('Error updating profile:', error);
                    this.showToast('Error updating profile: ' + error.message, 'error');
                }
            },

            async toggleFollow(targetEmail) {
                if (!this.data.currentUser) {
                    this.showToast('Please login to follow', 'error');
                    return;
                }
                
                if (targetEmail === this.data.currentUser.email) {
                    this.showToast('Cannot follow yourself', 'error');
                    return;
                }
                
                try {
                    const currentUserRef = db.collection('users').doc(this.data.currentUser.email);
                    const targetUserRef = db.collection('users').doc(targetEmail);
                    
                    const [currentDoc, targetDoc] = await Promise.all([
                        currentUserRef.get(),
                        targetUserRef.get()
                    ]);

                    if (!currentDoc.exists || !targetDoc.exists) {
                        this.showToast('User not found', 'error');
                        return;
                    }

                    const currentData = currentDoc.data();
                    const targetData = targetDoc.data();
                    
                    const currentFollowing = Array.isArray(currentData.following) ? currentData.following : [];
                    const targetFollowers = Array.isArray(targetData.followers) ? targetData.followers : [];

                    const isFollowing = currentFollowing.includes(targetEmail);

                    if (isFollowing) {
                        const newFollowing = currentFollowing.filter(e => e !== targetEmail);
                        const newFollowers = targetFollowers.filter(e => e !== this.data.currentUser.email);
                        
                        await currentUserRef.update({ following: newFollowing });
                        await targetUserRef.update({ followers: newFollowers });
                        
                        this.data.currentUser.following = newFollowing;
                        const targetUserIndex = this.data.users.findIndex(u => u.email === targetEmail);
                        if (targetUserIndex !== -1) {
                            this.data.users[targetUserIndex].followers = newFollowers;
                        }
                        
                        this.showToast(`Unfollowed ${targetData.tag}`);
                    } else {
                        const newFollowing = [...currentFollowing, targetEmail];
                        const newFollowers = [...targetFollowers, this.data.currentUser.email];
                        
                        await currentUserRef.update({ following: newFollowing });
                        await targetUserRef.update({ followers: newFollowers });
                        
                        this.data.currentUser.following = newFollowing;
                        const targetUserIndex = this.data.users.findIndex(u => u.email === targetEmail);
                        if (targetUserIndex !== -1) {
                            this.data.users[targetUserIndex].followers = newFollowers;
                        }
                        
                        // Check if mutual follow - if so, auto-accept any pending conversation
                        if (newFollowing.includes(targetEmail) && newFollowers.includes(this.data.currentUser.email)) {
                            const conversationId = this.getConversationId(this.data.currentUser.email, targetEmail);
                            const convDoc = await db.collection('conversations').doc(conversationId).get();
                            if (convDoc.exists && convDoc.data().status === 'pending') {
                                await db.collection('conversations').doc(conversationId).update({ status: 'accepted' });
                            }
                        }
                        
                        this.showToast(`You are now following ${targetData.tag}`);
                    }
                    
                    this.renderProfile(targetEmail);
                } catch (error) {
                    console.error('Error toggling follow:', error);
                    this.showToast('Error updating follow status: ' + error.message, 'error');
                }
            },

            showFollowersList(type, userEmail) {
                this.navigate('followers', { type, userEmail });
            },

            renderFollowersList(param) {
                const container = document.getElementById('followersListContainer');
                const title = document.getElementById('followersListTitle');
                
                if (!container || !title || !param) return;
                
                const user = this.data.users.find(u => u.email === param.userEmail);
                if (!user) return;
                
                title.innerText = param.type === 'followers' ? 'Followers' : 'Following';
                
                const list = param.type === 'followers' 
                    ? (Array.isArray(user.followers) ? user.followers : []) 
                    : (Array.isArray(user.following) ? user.following : []);
                
                if (list.length === 0) {
                    container.innerHTML = `<div class="text-center text-gray-500 py-8">No ${param.type.toLowerCase()} yet</div>`;
                    return;
                }
                
                container.innerHTML = list.map(email => {
                    const u = this.data.users.find(user => user.email === email);
                    if (!u) return '';
                    const isAdmin = this.admins.includes(email);
                    const isCurrentUser = this.data.currentUser?.email === email;
                    return `
                        <div class="flex items-center justify-between p-3 bg-gray-800 rounded-lg mb-2">
                            <div class="flex items-center gap-3 cursor-pointer" onclick="window.app.navigate('profile', '${u.email}')">
                                <img src="${u.pic || `https://ui-avatars.com/api/?name=${encodeURIComponent(u.displayName || u.tag)}&background=10b981&color=fff&size=64`}" 
                                     class="w-10 h-10 rounded-full object-cover"
                                     onerror="this.src='https://ui-avatars.com/api/?name=${encodeURIComponent(u.displayName || u.tag)}&background=10b981&color=fff&size=64'">
                                <div>
                                    <div class="text-white font-bold">${u.displayName || u.tag}</div>
                                    <div class="text-xs text-green-400">@${u.tag}</div>
                                    ${isCurrentUser ? '<div class="text-xs text-green-400">You</div>' : ''}
                                    ${isAdmin ? '<div class="text-xs text-pink-400">Admin</div>' : ''}
                                </div>
                            </div>
                            <button onclick="window.app.navigate('profile', '${u.email}')" class="px-4 py-1 bg-green-600 text-black rounded-full text-sm font-bold hover:bg-green-500">
                                View
                            </button>
                        </div>
                    `;
                }).join('');
            },

            searchUser() {
                const searchInput = document.getElementById('userSearchInput');
                const resultsContainer = document.getElementById('searchResults');
                let query = searchInput?.value?.trim().toLowerCase() || '';
                
                query = query.replace(/^@/, '');
                
                if (!query) {
                    if (resultsContainer) resultsContainer.innerHTML = '';
                    return;
                }
                
                const matches = this.data.users.filter(u => {
                    const tagMatch = u.tag?.toLowerCase().includes(query);
                    const nameMatch = u.displayName?.toLowerCase().includes(query);
                    const emailMatch = u.email?.toLowerCase().includes(query);
                    return tagMatch || nameMatch || emailMatch;
                });
                
                if (resultsContainer) {
                    if (matches.length === 0) {
                        resultsContainer.innerHTML = '<div class="text-gray-500 text-center py-4">No users found</div>';
                    } else {
                        resultsContainer.innerHTML = matches.map(u => {
                            const isCurrentUser = this.data.currentUser?.email === u.email;
                            const isAdmin = this.admins.includes(u.email);
                            return `
                                <div class="flex items-center justify-between p-3 bg-gray-800 rounded-lg mb-2">
                                    <div class="flex items-center gap-3 cursor-pointer" onclick="window.app.navigate('profile', '${u.email}')">
                                        <img src="${u.pic || `https://ui-avatars.com/api/?name=${encodeURIComponent(u.displayName || u.tag)}&background=10b981&color=fff&size=64`}" 
                                             class="w-10 h-10 rounded-full object-cover"
                                             onerror="this.src='https://ui-avatars.com/api/?name=${encodeURIComponent(u.displayName || u.tag)}&background=10b981&color=fff&size=64'">
                                        <div>
                                            <div class="text-white font-bold">${u.displayName || u.tag}</div>
                                            <div class="text-xs text-green-400">@${u.tag}</div>
                                            ${isCurrentUser ? '<div class="text-xs text-green-400">You</div>' : ''}
                                            ${isAdmin ? '<div class="text-xs text-pink-400">Admin</div>' : ''}
                                        </div>
                                    </div>
                                    <button onclick="window.app.navigate('profile', '${u.email}')" class="px-4 py-1 bg-green-600 text-black rounded-full text-sm font-bold hover:bg-green-500">
                                        View
                                    </button>
                                </div>
                            `;
                        }).join('');
                    }
                }
            },

            toggleAuthModal() {
                const modal = document.getElementById('authModal');
                if (!modal) return;
                
                if (modal.classList.contains('hidden')) {
                    modal.classList.remove('hidden');
                    this.resetAuthForm();
                } else {
                    modal.classList.add('hidden');
                }
            },

            switchAuthMode() {
                this.data.authMode = this.data.authMode === 'login' ? 'register' : 'login';
                const authTitle = document.getElementById('authTitle');
                const authBtnText = document.getElementById('authBtnText');
                const authSwitchText = document.getElementById('authSwitchText');
                const authSwitchBtn = document.getElementById('authSwitchBtn');
                
                if (authTitle) authTitle.innerText = this.data.authMode === 'login' ? 'Login' : 'Register';
                if (authBtnText) authBtnText.innerText = 'Request Code';
                if (authSwitchText) authSwitchText.innerText = this.data.authMode === 'login' ? "Don't have an account?" : "Already have an account?";
                if (authSwitchBtn) authSwitchBtn.innerText = this.data.authMode === 'login' ? 'Register' : 'Login';
                
                const verificationSection = document.getElementById('verificationSection');
                if (verificationSection) verificationSection.classList.add('hidden');
            },

            resetAuthForm() {
                const authForm = document.getElementById('authForm');
                const verificationSection = document.getElementById('verificationSection');
                const codeDisplay = document.getElementById('codeDisplay');
                
                if (authForm) authForm.reset();
                if (verificationSection) verificationSection.classList.add('hidden');
                if (codeDisplay) codeDisplay.classList.add('hidden');
                clearInterval(this.timerInterval);
                if (this.data.codeDisplayTimeout) {
                    clearTimeout(this.data.codeDisplayTimeout);
                }
            },

            requestCode() {
                const authEmail = document.getElementById('authEmail');
                const email = authEmail?.value?.trim();
                
                if (!email) {
                    this.showToast('Please enter email', 'error');
                    return;
                }

                this.data.verificationCode = Math.floor(100000 + Math.random() * 900000).toString();
                this.data.codeExpiry = Date.now() + 10 * 60 * 1000;

                console.log(`Verification code for ${email}: ${this.data.verificationCode}`);
                
                const verificationSection = document.getElementById('verificationSection');
                const authBtnText = document.getElementById('authBtnText');
                const codeDisplay = document.getElementById('codeDisplay');
                const codeValue = document.getElementById('codeValue');
                
                if (verificationSection) verificationSection.classList.remove('hidden');
                if (authBtnText) authBtnText.innerText = this.data.authMode === 'login' ? 'Login' : 'Create Account';
                
                if (codeDisplay && codeValue) {
                    codeDisplay.classList.remove('hidden');
                    codeValue.innerText = this.data.verificationCode;
                    
                    this.data.codeDisplayTimeout = setTimeout(() => {
                        codeDisplay.classList.add('hidden');
                    }, 10000);
                }
                
                this.showToast('Check the displayed code below (visible for 10 seconds)');
                this.startTimer();
            },

            startTimer() {
                const timerDisplay = document.getElementById('timerDisplay');
                clearInterval(this.timerInterval);
                
                this.timerInterval = setInterval(() => {
                    const now = Date.now();
                    const diff = this.data.codeExpiry - now;
                    
                    if (diff <= 0) {
                        if (timerDisplay) {
                            timerDisplay.innerText = "Expired";
                            timerDisplay.classList.add('text-gray-600');
                            timerDisplay.classList.remove('text-red-400');
                        }
                        clearInterval(this.timerInterval);
                    } else {
                        const mins = Math.floor(diff / 60000);
                        const secs = Math.floor((diff % 60000) / 1000);
                        if (timerDisplay) timerDisplay.innerText = `${mins}:${secs < 10 ? '0' : ''}${secs}`;
                    }
                }, 1000);
            },

            async handleAuth(e) {
                e.preventDefault();
                
                const authEmail = document.getElementById('authEmail');
                const authPassword = document.getElementById('authPassword');
                const authCode = document.getElementById('authCode');
                const verificationSection = document.getElementById('verificationSection');
                
                const email = authEmail?.value?.trim();
                const password = authPassword?.value;
                const code = authCode?.value;

                if (verificationSection?.classList.contains('hidden')) {
                    this.requestCode();
                    return;
                }

                if (code !== this.data.verificationCode || Date.now() > this.data.codeExpiry) {
                    this.showToast('Invalid or expired code', 'error');
                    return;
                }

                try {
                    if (this.data.authMode === 'register') {
                        const userDoc = await db.collection('users').doc(email).get();
                        if (userDoc.exists) {
                            this.showToast('Account already exists with this email', 'error');
                            return;
                        }
                        
                        await auth.createUserWithEmailAndPassword(email, password);
                        
                        const tag = email.split('@')[0].replace(/\s+/g, '');
                        
                        await db.collection('users').doc(email).set({
                            tag: tag,
                            displayName: tag,
                            pic: '',
                            following: [],
                            followers: [],
                            lastPostDate: null,
                            postsToday: 0,
                            createdAt: Date.now(),
                            country: 'US',
                            timezone: 'America/New_York',
                            lastTagChange: null,
                            suspended: null,
                            blockedUsers: []
                        });
                        
                        this.showToast('Account created successfully! You are now logged in.');
                        
                    } else {
                        await auth.signInWithEmailAndPassword(email, password);
                        this.showToast('Logged in successfully!');
                    }

                    this.toggleAuthModal();
                } catch (error) {
                    console.error('Auth error:', error);
                    this.showToast(error.message, 'error');
                }
            },

            updateAuthUI() {
                const loginBtn = document.getElementById('loginBtn');
                if (!loginBtn) return;
                
                if (this.data.currentUser) {
                    loginBtn.innerText = 'Logout';
                    loginBtn.onclick = async () => {
                        await auth.signOut();
                        this.data.currentUser = null;
                        this.stopRealtimeListeners();
                        this.updateAuthUI();
                        this.showToast('Logged out');
                        this.navigate('home');
                    };
                } else {
                    loginBtn.innerText = 'Login';
                    loginBtn.onclick = () => this.toggleAuthModal();
                }
            },

            showToast(msg, type = 'success') {
                const toast = document.getElementById('toast');
                const toastMsg = document.getElementById('toastMsg');
                
                if (!toast || !toastMsg) return;
                
                const icon = toast.querySelector('i');
                
                toastMsg.innerText = msg;
                if (type === 'error') {
                    toast.classList.remove('border-green-500');
                    toast.classList.add('border-red-500');
                    if (icon) icon.className = 'fa-solid fa-circle-exclamation text-red-500';
                } else {
                    toast.classList.remove('border-red-500');
                    toast.classList.add('border-green-500');
                    if (icon) icon.className = 'fa-solid fa-check-circle text-green-500';
                }

                toast.classList.remove('translate-y-20', 'opacity-0');
                setTimeout(() => {
                    toast.classList.add('translate-y-20', 'opacity-0');
                }, 3000);
            },
            
            setupEventListeners() {
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        const modal = document.getElementById('authModal');
                        const commentModal = document.getElementById('commentModal');
                        const replyModal = document.getElementById('replyModal');
                        const imageViewer = document.getElementById('imageViewer');
                        const messageRequestModal = document.getElementById('messageRequestModal');
                        const acceptRejectModal = document.getElementById('acceptRejectModal');
                        const pendingRequestModal = document.getElementById('pendingRequestModal');
                        const suspendModal = document.getElementById('suspendModal');
                        
                        if (imageViewer && !imageViewer.classList.contains('hidden')) {
                            this.closeImageViewer();
                            return;
                        }
                        if (modal && !modal.classList.contains('hidden')) {
                            this.toggleAuthModal();
                        }
                        if (commentModal && !commentModal.classList.contains('hidden')) {
                            this.closeCommentModal();
                        }
                        if (replyModal && !replyModal.classList.contains('hidden')) {
                            this.closeReplyModal();
                        }
                        if (messageRequestModal && !messageRequestModal.classList.contains('hidden')) {
                            this.closeMessageRequestModal();
                        }
                        if (acceptRejectModal && !acceptRejectModal.classList.contains('hidden')) {
                            this.closeAcceptRejectModal();
                        }
                        if (pendingRequestModal && !pendingRequestModal.classList.contains('hidden')) {
                            this.closePendingRequestModal();
                        }
                        if (suspendModal && !suspendModal.classList.contains('hidden')) {
                            this.closeSuspendModal();
                        }
                    }
                });
            }
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => window.app.init());
        } else {
            window.app.init();
        }
    </script>
    <style>
        body {
            font-family: 'Space Grotesk', sans-serif;
            background-color: #050505;
            color: #e0e0e0;
            overflow-x: hidden;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #0f172a; 
        }
        ::-webkit-scrollbar-thumb {
            background: #334155; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #475569; 
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        .animate-float {
            animation: float 4s ease-in-out infinite;
        }

        @keyframes glow {
            0% { box-shadow: 0 0 5px #10b981; }
            50% { box-shadow: 0 0 20px #10b981, 0 0 10px #34d399; }
            100% { box-shadow: 0 0 5px #10b981; }
        }
        .btn-glow:hover {
            animation: glow 1.5s infinite alternate;
        }

        .glass-panel {
            background: rgba(15, 23, 42, 0.7);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .neon-text {
            text-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
        }
        
        .neon-text-pink {
            text-shadow: 0 0 10px rgba(236, 72, 153, 0.5);
        }

        .chart-line {
            stroke-dasharray: 1000;
            stroke-dashoffset: 1000;
            animation: drawChart 3s ease-out forwards;
        }
        @keyframes drawChart {
            to { stroke-dashoffset: 0; }
        }

        .category-pill.active {
            background-color: #10b981;
            color: #000;
            border-color: #10b981;
            box-shadow: 0 0 15px rgba(16, 185, 129, 0.4);
        }

        .code-display {
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .mention {
            color: #60a5fa;
            font-weight: bold;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #10b981;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        img {
            max-width: 100%;
            height: auto;
        }
        
        .profile-image-container {
            width: 96px;
            height: 96px;
            border-radius: 50%;
            overflow: hidden;
            border: 4px solid #10b981;
            background-color: #1f2937;
            flex-shrink: 0;
        }
        
        .profile-image-container img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            display: block;
        }

        /* Image viewer styles */
        .image-viewer {
            position: fixed;
            inset: 0;
            z-index: 200;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .image-viewer img {
            max-width: 95%;
            max-height: 85vh;
            object-fit: contain;
        }

        .image-viewer-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .image-viewer-title {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 1.2rem;
            text-align: center;
            max-width: 90%;
        }

        /* FAQ Styles */
        .faq-item {
            border-bottom: 1px solid rgba(255,255,255,0.1);
            padding: 1rem 0;
        }
        .faq-question {
            font-weight: 600;
            color: #10b981;
            margin-bottom: 0.5rem;
        }
        .faq-answer {
            color: #9ca3af;
            line-height: 1.6;
        }

        /* Chat styles */
        .chat-container {
            display: flex;
            flex-direction: column;
            height: 70vh;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }
        
        .chat-input {
            padding: 1rem;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        /* FIXED: Profile buttons layout for better visibility */
        .profile-actions {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: stretch;
            width: 100%;
            max-width: 200px;
        }

        @media (min-width: 768px) {
            .profile-actions {
                flex-direction: row;
                flex-wrap: wrap;
                justify-content: flex-end;
                max-width: none;
            }
        }

        .profile-btn {
            width: 100%;
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            font-weight: 700;
            font-size: 0.875rem;
            transition: all 0.2s;
            white-space: nowrap;
        }

        @media (min-width: 768px) {
            .profile-btn {
                width: auto;
            }
        }
    </style>
</head>
<body class="min-h-screen flex flex-col relative">

    <!-- Image Viewer Modal -->
    <div id="imageViewer" class="image-viewer hidden" onclick="if(event.target === this) window.app.closeImageViewer()">
        <div class="image-viewer-controls">
            <button onclick="window.app.closeImageViewer()" class="bg-gray-800 hover:bg-gray-700 text-white p-3 rounded-full transition-colors">
                <i class="fa-solid fa-times text-xl"></i>
            </button>
        </div>
        <img id="viewerImage" src="" alt="Post Image">
        <div id="viewerTitle" class="image-viewer-title"></div>
    </div>

    <div class="fixed inset-0 z-0 pointer-events-none overflow-hidden">
        <div class="absolute inset-0 bg-[linear-gradient(to_right,#1f2937_1px,transparent_1px),linear-gradient(to_bottom,#1f2937_1px,transparent_1px)] bg-[size:4rem_4rem] [mask-image:radial-gradient(ellipse_60%_50%_at_50%_0%,#000_70%,transparent_100%)] opacity-20"></div>
        
        <div class="absolute top-20 left-10 opacity-10 animate-float" style="animation-delay: 0s;">
            <svg width="100" height="100" viewBox="0 0 24 24" fill="#4ade80"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>
        </div>
        <div class="absolute bottom-40 right-10 opacity-10 animate-float" style="animation-delay: 2s;">
            <svg width="150" height="150" viewBox="0 0 24 24" fill="#4ade80"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-1 17.93c-3.95-.49-7-3.85-7-7.93 0-.62.08-1.21.21-1.79L9 15v1c0 1.1.9 2 2 2v1.93zm6.9-2.54c-.26-.81-1-1.39-1.9-1.39h-1v-3c0-.55-.45-1-1-1H8v-2h2c.55 0 1-.45 1-1V7h2c1.1 0 2-.9 2-2v-.41c2.93 1.19 5 4.06 5 7.41 0 2.08-.8 3.97-2.1 5.39z"/></svg>
        </div>

        <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-[800px] h-[600px] opacity-20 pointer-events-none">
            <div class="absolute bottom-0 left-1/2 transform -translate-x-1/2 w-[600px] h-[20px] bg-gray-800 rounded-b-xl border-t border-gray-600"></div>
            <div class="absolute bottom-[20px] left-1/2 transform -translate-x-1/2 w-[500px] h-[300px] bg-gray-900 border-4 border-gray-700 rounded-t-lg overflow-hidden">
                <div class="w-full h-full bg-black p-4 relative">
                    <svg class="w-full h-full" viewBox="0 0 100 50" preserveAspectRatio="none">
                        <path d="M0,50 L10,45 L20,48 L30,30 L40,35 L50,15 L60,20 L70,10 L80,12 L90,5 L100,0" 
                              fill="none" stroke="#10b981" stroke-width="2" class="chart-line" />
                        <path d="M0,50 L10,45 L20,48 L30,30 L40,35 L50,15 L60,20 L70,10 L80,12 L90,5 L100,0 L100,50 Z" 
                              fill="url(#grad1)" opacity="0.2" />
                        <defs>
                            <linearGradient id="grad1" x1="0%" y1="0%" x2="0%" y2="100%">
                                <stop offset="0%" style="stop-color:#10b981;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#10b981;stop-opacity:0" />
                            </linearGradient>
                        </defs>
                    </svg>
                    <div class="absolute top-2 left-2 w-20 h-2 bg-gray-800 rounded"></div>
                    <div class="absolute top-2 right-2 w-8 h-2 bg-red-900 rounded"></div>
                </div>
            </div>
        </div>
    </div>

    <nav class="fixed top-0 w-full z-50 glass-panel border-b border-gray-800">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <div class="flex items-center cursor-pointer" onclick="window.app.navigate('home')">
                    <div class="flex-shrink-0 text-green-400 text-2xl font-bold tracking-tighter flex items-center gap-2">
                        <i class="fa-solid fa-rocket"></i>
                        <span>MEME<span class="text-white">MEDIA</span></span>
                    </div>
                </div>
                <div class="hidden md:block">
                    <div class="ml-10 flex items-baseline space-x-4">
                        <button onclick="window.app.navigate('home')" class="hover:bg-gray-800 px-3 py-2 rounded-md text-sm font-medium transition-colors">Home</button>
                        <button onclick="window.app.navigate('profile')" class="hover:bg-gray-800 px-3 py-2 rounded-md text-sm font-medium transition-colors">Profile</button>
                        <button onclick="window.app.navigate('search')" class="hover:bg-gray-800 px-3 py-2 rounded-md text-sm font-medium transition-colors">Find Users</button>
                        <button onclick="window.app.navigate('messages')" class="hover:bg-gray-800 px-3 py-2 rounded-md text-sm font-medium transition-colors">Messages</button>
                    </div>
                </div>
                <div class="flex items-center gap-4">
                    <button id="newPostBtn" onclick="window.app.handleNewPostClick()" class="bg-green-600 hover:bg-green-500 text-black font-bold py-2 px-4 rounded-lg transition-all transform hover:scale-105 btn-glow flex items-center gap-2">
                        <i class="fa-solid fa-plus"></i> New Post
                    </button>
                    <button id="loginBtn" onclick="window.app.toggleAuthModal()" class="border border-green-500 text-green-400 hover:bg-green-500/10 px-4 py-2 rounded-lg transition-all">
                        Login
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <main class="flex-grow pt-24 pb-12 px-4 sm:px-6 lg:px-8 max-w-4xl mx-auto w-full z-10 relative">
        
        <div class="text-center mb-12 animate-float">
            <h1 class="text-5xl md:text-7xl font-bold mb-4 tracking-tight">
                <span class="text-transparent bg-clip-text bg-gradient-to-r from-green-400 to-emerald-600 neon-text">$MEME</span>
                <span class="text-white">MEDIA</span>
            </h1>
            <p class="text-gray-400 text-lg max-w-2xl mx-auto">The decentralized hub for memecoin intelligence, rug alerts, and alpha leaks.</p>
            
            <!-- Telegram and FAQ Buttons -->
            <div class="flex justify-center items-center gap-4 mt-6">
                <a href="https://t.me/+Fyje6BSEVz41Yjlk" target="_blank" 
                   class="inline-flex items-center gap-2 bg-[#0088cc] hover:bg-[#0077b3] text-white font-bold py-3 px-6 rounded-full transition-all transform hover:scale-105 shadow-lg shadow-[#0088cc]/30">
                    <i class="fa-brands fa-telegram text-2xl"></i>
                    <span>Join Telegram</span>
                </a>
                <button onclick="window.app.navigate('faq')" 
                        class="w-12 h-12 rounded-full bg-gray-800 hover:bg-gray-700 border border-gray-600 text-white font-bold text-sm transition-all hover:scale-110 flex items-center justify-center"
                        title="FAQ">
                    FAQ
                </button>
            </div>
        </div>

        <!-- FIXED: Single column layout for posts -->
        <div id="homeView" class="space-y-8">
            <div class="flex justify-center space-x-4 mb-8">
                <button onclick="window.app.switchTab('all')" id="tab-all" class="px-8 py-3 rounded-full border border-green-500/30 bg-green-500/10 text-green-400 font-semibold transition-all hover:bg-green-500/20 active-tab">
                    <i class="fa-solid fa-newspaper mr-2"></i> All News
                </button>
                <button onclick="window.app.switchTab('top')" id="tab-top" class="px-8 py-3 rounded-full border border-pink-500/30 bg-gray-900 text-gray-400 font-semibold transition-all hover:bg-pink-500/10 hover:text-pink-400">
                    <i class="fa-solid fa-crown mr-2 text-yellow-500"></i> Top News
                </button>
            </div>

            <div id="allNewsControls" class="max-w-3xl mx-auto space-y-6">
                <div class="relative">
                    <input type="text" id="searchInput" placeholder="Search posts by keyword..." 
                           class="w-full bg-gray-900/80 border border-gray-700 rounded-xl py-4 pl-12 pr-4 text-white focus:outline-none focus:border-green-500 focus:ring-1 focus:ring-green-500 transition-all"
                           oninput="window.app.filterPosts()">
                    <i class="fa-solid fa-search absolute left-4 top-1/2 transform -translate-y-1/2 text-gray-500"></i>
                </div>

                <div class="flex flex-wrap justify-center gap-3" id="categoryFilters">
                    <button onclick="window.app.setCategory('All')" class="category-pill active px-4 py-2 rounded-full border border-gray-700 bg-gray-800 text-sm hover:border-green-500 transition-all">All</button>
                    <button onclick="window.app.setCategory('Moonshots')" class="category-pill px-4 py-2 rounded-full border border-gray-700 bg-gray-800 text-sm hover:border-green-500 transition-all">🚀 Moonshots</button>
                    <button onclick="window.app.setCategory('Rug Alerts')" class="category-pill px-4 py-2 rounded-full border border-gray-700 bg-gray-800 text-sm hover:border-green-500 transition-all">🚨 Rug Alerts</button>
                    <button onclick="window.app.setCategory('Alpha')" class="category-pill px-4 py-2 rounded-full border border-gray-700 bg-gray-800 text-sm hover:border-green-500 transition-all">💎 Alpha</button>
                    <button onclick="window.app.setCategory('Trends')" class="category-pill px-4 py-2 rounded-full border border-gray-700 bg-gray-800 text-sm hover:border-green-500 transition-all">📈 Trends</button>
                </div>
            </div>

            <!-- FIXED: Single column posts container -->
            <div id="postsContainer" class="space-y-6 mt-8">
            </div>
        </div>

        <div id="createPostView" class="hidden max-w-2xl mx-auto glass-panel p-8 rounded-2xl border border-gray-700">
            <h2 class="text-2xl font-bold text-white mb-6 flex items-center gap-2">
                <i class="fa-solid fa-pen-nib text-green-400"></i> Create New Post
            </h2>
            <form onsubmit="window.app.submitPost(event)" class="space-y-6">
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-2">Title</label>
                    <input type="text" name="title" required class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none">
                </div>
                
                <div id="postTypeSection" class="hidden">
                    <label class="block text-sm font-medium text-gray-400 mb-2">Post Type</label>
                    <select id="postTypeSelect" class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none">
                        <option value="all">All News</option>
                        <option value="top">Top News (Admin Only)</option>
                    </select>
                </div>
                
                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-2">Category</label>
                    <select name="category" class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none">
                        <option value="Moonshots">🚀 Moonshots</option>
                        <option value="Rug Alerts">🚨 Rug Alerts</option>
                        <option value="Alpha">💎 Alpha</option>
                        <option value="Trends">📈 Trends</option>
                    </select>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-2">Content</label>
                    <textarea name="content" rows="5" required class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none"></textarea>
                </div>

                <div>
                    <label class="block text-sm font-medium text-gray-400 mb-2">Image URL</label>
                    <input type="url" name="imageUrl" placeholder="https://..." class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none">
                    <p class="text-xs text-gray-500 mt-1">Need an image host? Try <a href="https://aarifalam.life/tools/image-to-url" target="_blank" class="text-green-400 hover:underline">Image to URL Converter</a></p>
                </div>

                <div class="flex gap-4 pt-4">
                    <button type="button" onclick="window.app.navigate('home')" class="flex-1 py-3 rounded-lg border border-gray-600 text-gray-300 hover:bg-gray-800 transition-colors">Cancel</button>
                    <button type="submit" class="flex-1 py-3 rounded-lg bg-green-600 text-black font-bold hover:bg-green-500 transition-colors">Publish Post</button>
                </div>
            </form>
        </div>

        <div id="profileView" class="hidden max-w-4xl mx-auto">
            <!-- Suspension Countdown (visible to suspended user and admins) -->
            <div id="suspendCountdown" class="hidden"></div>
            
            <div class="glass-panel rounded-2xl p-8 mb-8 border border-gray-700 relative overflow-hidden">
                <div class="absolute top-0 left-0 w-full h-24 bg-gradient-to-r from-green-900/50 to-blue-900/50"></div>
                <div class="relative z-10 flex flex-col md:flex-row items-center md:items-end gap-6 mt-8">
                    <div class="profile-image-container">
                        <img id="profileImage" src="https://ui-avatars.com/api/?name=User&background=10b981&color=fff&size=128&format=png" class="w-full h-full object-cover">
                    </div>
                    <div class="flex-grow text-center md:text-left">
                        <h2 id="profileName" class="text-3xl font-bold text-white">User Name</h2>
                        <p id="profileTag" class="text-green-400 font-mono">@usertag</p>
                        <p id="profileEmailDisplay" class="text-gray-500 text-sm mt-1 hidden"></p>
                        <p id="profileCountryDisplay" class="text-gray-400 text-sm mt-1 hidden"></p>
                    </div>
                    <div class="flex gap-4 text-center">
                        <div class="cursor-pointer hover:bg-gray-800 p-2 rounded-lg transition-colors" 
                             onclick="window.app.showFollowersList('posts', window.app.data.profileViewUser || window.app.data.currentUser?.email)">
                            <div class="text-xl font-bold text-white" id="profilePostsCount">0</div>
                            <div class="text-xs text-gray-400 uppercase tracking-wider">Posts</div>
                        </div>
                        <div class="cursor-pointer hover:bg-gray-800 p-2 rounded-lg transition-colors" 
                             onclick="window.app.showFollowersList('followers', window.app.data.profileViewUser || window.app.data.currentUser?.email)">
                            <div class="text-xl font-bold text-white" id="profileFollowers">0</div>
                            <div class="text-xs text-gray-400 uppercase tracking-wider">Followers</div>
                        </div>
                        <div class="cursor-pointer hover:bg-gray-800 p-2 rounded-lg transition-colors" 
                             onclick="window.app.showFollowersList('following', window.app.data.profileViewUser || window.app.data.currentUser?.email)">
                            <div class="text-xl font-bold text-white" id="profileFollowing">0</div>
                            <div class="text-xs text-gray-400 uppercase tracking-wider">Following</div>
                        </div>
                    </div>
                    <!-- FIXED: Better button layout with profile-actions class -->
                    <div class="profile-actions">
                        <button id="notificationBtn" onclick="window.app.navigate('notifications')" class="hidden relative p-3 rounded-full bg-gray-800 hover:bg-gray-700 transition-colors w-12 h-12 flex items-center justify-center">
                            <i class="fa-solid fa-bell text-white text-xl"></i>
                            <span id="notificationBadge" class="hidden absolute -top-1 -right-1 bg-red-500 text-white text-xs rounded-full w-5 h-5 flex items-center justify-center">0</span>
                        </button>
                        <!-- Follow button -->
                        <button id="followBtn" onclick="window.app.toggleFollow()" class="hidden profile-btn bg-white text-black hover:bg-gray-200">Follow</button>
                        <!-- Message button -->
                        <button id="messageBtn" onclick="window.app.startMessage()" class="hidden profile-btn bg-blue-600 text-white hover:bg-blue-500 flex items-center justify-center gap-2">
                            <i class="fa-solid fa-message"></i> Message
                        </button>
                        <!-- Suspend button - visible only to admins -->
                        <button id="suspendBtn" onclick="window.app.showSuspendModal()" class="hidden profile-btn bg-red-600 text-white hover:bg-red-500">
                            Suspend User
                        </button>
                    </div>
                </div>
            </div>

            <div id="editProfileSection" class="glass-panel rounded-xl p-6 mb-8 border border-gray-700 hidden">
                <h3 class="text-lg font-bold text-white mb-4">Edit Profile</h3>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                        <label class="block text-xs text-gray-400 mb-1">Display Name</label>
                        <input type="text" id="editDisplayNameInput" placeholder="Your display name..." class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-400 mb-1">User Tag (no spaces)</label>
                        <input type="text" id="editTagInput" placeholder="Set unique user tag..." class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-400 mb-1">Profile Picture URL</label>
                        <input type="url" id="editPicInput" placeholder="Profile Picture URL..." class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-400 mb-1">Country</label>
                        <select id="countrySelect" class="w-full bg-gray-900 border border-gray-700 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none">
                            <!-- Populated by JS -->
                        </select>
                    </div>
                </div>
                <button onclick="window.app.saveProfile()" class="mt-4 px-6 py-2 bg-green-600 text-black font-bold rounded-lg hover:bg-green-500">Save Changes</button>
            </div>

            <h3 class="text-xl font-bold text-white mb-4 border-l-4 border-green-500 pl-3">Posts</h3>
            <div id="userPostsContainer" class="space-y-4">
            </div>
        </div>

        <div id="searchUserView" class="hidden max-w-2xl mx-auto">
            <div class="glass-panel rounded-2xl p-8 border border-gray-700">
                <h2 class="text-2xl font-bold text-white mb-6 flex items-center gap-2">
                    <i class="fa-solid fa-search text-green-400"></i> Find Users
                </h2>
                <div class="relative mb-6">
                    <input type="text" id="userSearchInput" placeholder="Search by username or email..." 
                           class="w-full bg-gray-900 border border-gray-700 rounded-lg p-4 pl-12 text-white focus:border-green-500 focus:outline-none"
                           oninput="window.app.searchUser()">
                    <i class="fa-solid fa-search absolute left-4 top-1/2 transform -translate-y-1/2 text-gray-500"></i>
                </div>
                <div id="searchResults" class="space-y-2">
                </div>
            </div>
        </div>

        <div id="followersView" class="hidden max-w-2xl mx-auto">
            <div class="glass-panel rounded-2xl p-8 border border-gray-700">
                <div class="flex justify-between items-center mb-6">
                    <h2 id="followersListTitle" class="text-2xl font-bold text-white flex items-center gap-2">
                        <i class="fa-solid fa-users text-green-400"></i> Followers
                    </h2>
                    <button onclick="window.app.navigate('profile', window.app.data.profileViewUser || window.app.data.currentUser?.email)" class="text-gray-400 hover:text-white">
                        <i class="fa-solid fa-times text-xl"></i>
                    </button>
                </div>
                <div id="followersListContainer" class="space-y-2">
                </div>
            </div>
        </div>

        <div id="notificationsView" class="hidden max-w-2xl mx-auto">
            <div class="glass-panel rounded-2xl p-8 border border-gray-700">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold text-white flex items-center gap-2">
                        <i class="fa-solid fa-bell text-green-400"></i> Notifications
                    </h2>
                    <button onclick="window.app.navigate('profile')" class="text-gray-400 hover:text-white">
                        <i class="fa-solid fa-times text-xl"></i>
                    </button>
                </div>
                <div id="notificationsList" class="space-y-3">
                    <div class="text-center text-gray-500 py-8">Loading notifications...</div>
                </div>
                <div class="mt-6 p-4 bg-gray-800/50 rounded-lg">
                    <p class="text-xs text-gray-500 text-center">
                        <i class="fa-solid fa-clock mr-1"></i> Notifications expire after 24 hours
                    </p>
                </div>
            </div>
        </div>

        <!-- Messages List View -->
        <div id="messagesView" class="hidden max-w-2xl mx-auto">
            <div class="glass-panel rounded-2xl p-8 border border-gray-700">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold text-white flex items-center gap-2">
                        <i class="fa-solid fa-message text-green-400"></i> Messages
                    </h2>
                    <button onclick="window.app.navigate('home')" class="text-gray-400 hover:text-white">
                        <i class="fa-solid fa-times text-xl"></i>
                    </button>
                </div>
                <div id="messagesListContainer" class="space-y-3">
                    <div class="text-center text-gray-500 py-8">Loading conversations...</div>
                </div>
            </div>
        </div>

        <!-- Chat View -->
        <div id="chatView" class="hidden max-w-2xl mx-auto">
            <div id="chatContainer" class="glass-panel rounded-2xl border border-gray-700 hidden chat-container">
                <div id="chatHeader" class="p-4 border-b border-gray-700"></div>
                <div id="chatMessages" class="chat-messages"></div>
                <div id="chatInputContainer" class="chat-input"></div>
            </div>
        </div>

        <!-- FAQ View -->
        <div id="faqView" class="hidden max-w-3xl mx-auto">
            <div class="glass-panel rounded-2xl p-8 border border-gray-700">
                <div class="flex justify-between items-center mb-6">
                    <h2 class="text-2xl font-bold text-white flex items-center gap-2">
                        <i class="fa-solid fa-circle-question text-green-400"></i> Frequently Asked Questions
                    </h2>
                    <button onclick="window.app.navigate('home')" class="text-gray-400 hover:text-white">
                        <i class="fa-solid fa-times text-xl"></i>
                    </button>
                </div>
                
                <div class="space-y-4">
                    <div class="faq-item">
                        <div class="faq-question">What is MeMe Media?</div>
                        <div class="faq-answer">MeMe Media is a universal site for all memecoin related topics.</div>
                    </div>
                    
                    <div class="faq-item">
                        <div class="faq-question">What can I find in MeMe Media?</div>
                        <div class="faq-answer">You can find Alphas on time, get alerts on past or future Rugs, get trending topics and potential memecoin calls, all from your fellow meme enthusiast.</div>
                    </div>
                    
                    <div class="faq-item">
                        <div class="faq-question">Where can I find my profile and find users button?</div>
                        <div class="faq-answer">Simply switch your browser to desktop mode if you're using a phone, then switch back when you're done.</div>
                    </div>
                    
                    <div class="faq-item">
                        <div class="faq-question">Why can't I change my user tag?</div>
                        <div class="faq-answer">User tags can only be changed once every 30 days.</div>
                    </div>
                    
                    <div class="faq-item">
                        <div class="faq-question">Why can't I make more than 3 posts?</div>
                        <div class="faq-answer">Only 3 posts per day is allowed, once it's a new day you can make 3 posts once again, this is to eliminate flooding.</div>
                    </div>
                    
                    <div class="faq-item">
                        <div class="faq-question">Why was my post deleted?</div>
                        <div class="faq-answer">Your post might carry inappropriate images or context.</div>
                    </div>
                    
                    <div class="faq-item">
                        <div class="faq-question">How do I make a report or contact support?</div>
                        <div class="faq-answer">On your homepage you'll see a telegram icon, please contact us there.</div>
                    </div>
                </div>
                
                <div class="mt-8 p-4 bg-green-600/20 border border-green-500/30 rounded-lg text-center">
                    <p class="text-green-400 text-sm">Still have questions? Join our Telegram community!</p>
                    <a href="https://t.me/+Fyje6BSEVz41Yjlk" target="_blank" class="inline-flex items-center gap-2 mt-2 text-white hover:text-green-400 transition-colors">
                        <i class="fa-brands fa-telegram"></i> Join Telegram Group
                    </a>
                </div>
            </div>
        </div>

    </main>

    <div id="authModal" class="fixed inset-0 z-[100] hidden">
        <div class="absolute inset-0 bg-black/80 backdrop-blur-sm" onclick="window.app.toggleAuthModal()"></div>
        <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-full max-w-md p-1">
            <div class="bg-gray-900 border border-gray-700 rounded-2xl p-8 shadow-2xl relative overflow-hidden">
                <div class="absolute -top-10 -right-10 w-32 h-32 bg-green-500/20 rounded-full blur-3xl"></div>

                <div class="flex justify-between items-center mb-6">
                    <h2 id="authTitle" class="text-2xl font-bold text-white">Login</h2>
                    <button onclick="window.app.toggleAuthModal()" class="text-gray-400 hover:text-white"><i class="fa-solid fa-times"></i></button>
                </div>

                <form id="authForm" onsubmit="window.app.handleAuth(event)" class="space-y-4">
                    <div>
                        <label class="block text-sm text-gray-400 mb-1">Email Address</label>
                        <input type="email" id="authEmail" required class="w-full bg-black border border-gray-700 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none">
                    </div>
                    <div>
                        <label class="block text-sm text-gray-400 mb-1">Password</label>
                        <input type="password" id="authPassword" required class="w-full bg-black border border-gray-700 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none">
                    </div>
                    
                    <div id="verificationSection" class="hidden space-y-2 p-3 bg-gray-800/50 rounded-lg border border-gray-700">
                        <div class="flex justify-between items-center">
                            <label class="block text-sm text-green-400 font-bold">Verification Code</label>
                            <span id="timerDisplay" class="text-xs text-red-400 font-mono">10:00</span>
                        </div>
                        <input type="text" id="authCode" placeholder="Enter 6-digit code" class="w-full bg-black border border-gray-600 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none font-mono tracking-widest text-center text-lg">
                        
                        <div id="codeDisplay" class="hidden code-display bg-green-600 text-black p-4 rounded-lg text-center">
                            <div class="text-xs font-bold uppercase mb-1">Your Verification Code</div>
                            <div id="codeValue" class="text-3xl font-bold tracking-widest"></div>
                            <div class="text-xs mt-1 opacity-75">Visible for 10 seconds only</div>
                        </div>
                        
                        <button type="button" onclick="window.app.requestCode()" class="w-full text-xs text-gray-400 hover:text-white underline">Resend Code</button>
                    </div>

                    <button type="submit" id="authSubmitBtn" class="w-full bg-green-600 text-black font-bold py-3 rounded-lg hover:bg-green-500 transition-colors mt-2">
                        <span id="authBtnText">Request Code</span>
                    </button>
                </form>

                <div class="mt-6 text-center">
                    <p class="text-sm text-gray-400">
                        <span id="authSwitchText">Don't have an account?</span>
                        <button onclick="window.app.switchAuthMode()" class="text-green-400 hover:underline ml-1 font-medium" id="authSwitchBtn">Register</button>
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- Comment Modal -->
    <div id="commentModal" class="fixed inset-0 z-[100] hidden">
        <div class="absolute inset-0 bg-black/80 backdrop-blur-sm" onclick="window.app.closeCommentModal()"></div>
        <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-full max-w-md p-1">
            <div class="bg-gray-900 border border-gray-700 rounded-2xl p-6 shadow-2xl">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-white">Add Comment</h3>
                    <button onclick="window.app.closeCommentModal()" class="text-gray-400 hover:text-white"><i class="fa-solid fa-times"></i></button>
                </div>
                <textarea id="commentInput" rows="4" placeholder="Write your comment... Use @username to mention" class="w-full bg-black border border-gray-700 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none mb-4"></textarea>
                <input type="url" id="commentImageInput" placeholder="Image URL (optional)..." class="w-full bg-black border border-gray-700 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none mb-4 text-sm">
                <div class="flex gap-3">
                    <button onclick="window.app.closeCommentModal()" class="flex-1 py-2 rounded-lg border border-gray-600 text-gray-300 hover:bg-gray-800 transition-colors">Cancel</button>
                    <button id="submitCommentBtn" class="flex-1 py-2 rounded-lg bg-green-600 text-black font-bold hover:bg-green-500 transition-colors">Post Comment</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Reply Modal -->
    <div id="replyModal" class="fixed inset-0 z-[100] hidden">
        <div class="absolute inset-0 bg-black/80 backdrop-blur-sm" onclick="window.app.closeReplyModal()"></div>
        <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-full max-w-md p-1">
            <div class="bg-gray-900 border border-gray-700 rounded-2xl p-6 shadow-2xl">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-white">Reply</h3>
                    <button onclick="window.app.closeReplyModal()" class="text-gray-400 hover:text-white"><i class="fa-solid fa-times"></i></button>
                </div>
                <textarea id="replyInput" rows="4" placeholder="Write your reply..." class="w-full bg-black border border-gray-700 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none mb-4"></textarea>
                <input type="url" id="replyImageInput" placeholder="Image URL (optional)..." class="w-full bg-black border border-gray-700 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none mb-4 text-sm">
                <div class="flex gap-3">
                    <button onclick="window.app.closeReplyModal()" class="flex-1 py-2 rounded-lg border border-gray-600 text-gray-300 hover:bg-gray-800 transition-colors">Cancel</button>
                    <button id="submitReplyBtn" class="flex-1 py-2 rounded-lg bg-green-600 text-black font-bold hover:bg-green-500 transition-colors">Post Reply</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Message Request Modal -->
    <div id="messageRequestModal" class="fixed inset-0 z-[100] hidden">
        <div class="absolute inset-0 bg-black/80 backdrop-blur-sm" onclick="window.app.closeMessageRequestModal()"></div>
        <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-full max-w-md p-1">
            <div class="bg-gray-900 border border-gray-700 rounded-2xl p-6 shadow-2xl">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-white">Send Message Request</h3>
                    <button onclick="window.app.closeMessageRequestModal()" class="text-gray-400 hover:text-white"><i class="fa-solid fa-times"></i></button>
                </div>
                <p class="text-gray-400 text-sm mb-4">Send a message to start a conversation. The user will need to accept your request.</p>
                <textarea id="messageRequestInput" rows="4" placeholder="Write your message..." class="w-full bg-black border border-gray-700 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none mb-4"></textarea>
                <input type="url" id="messageRequestImageInput" placeholder="Image URL (optional)..." class="w-full bg-black border border-gray-700 rounded-lg p-3 text-white focus:border-green-500 focus:outline-none mb-4 text-sm">
                <div class="flex gap-3">
                    <button onclick="window.app.closeMessageRequestModal()" class="flex-1 py-2 rounded-lg border border-gray-600 text-gray-300 hover:bg-gray-800 transition-colors">Cancel</button>
                    <button id="sendMessageRequestBtn" class="flex-1 py-2 rounded-lg bg-blue-600 text-white font-bold hover:bg-blue-500 transition-colors">Send Message</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Accept/Reject Modal -->
    <div id="acceptRejectModal" class="fixed inset-0 z-[100] hidden">
        <div class="absolute inset-0 bg-black/80 backdrop-blur-sm" onclick="window.app.closeAcceptRejectModal()"></div>
        <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-full max-w-md p-1">
            <div class="bg-gray-900 border border-gray-700 rounded-2xl p-6 shadow-2xl">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-white">Message Request</h3>
                    <button onclick="window.app.closeAcceptRejectModal()" class="text-gray-400 hover:text-white"><i class="fa-solid fa-times"></i></button>
                </div>
                <p id="acceptRejectText" class="text-gray-300 text-sm mb-4"></p>
                <div class="flex gap-3">
                    <button onclick="window.app.closeAcceptRejectModal()" class="flex-1 py-2 rounded-lg border border-gray-600 text-gray-300 hover:bg-gray-800 transition-colors">Cancel</button>
                    <button id="rejectRequestBtn" class="flex-1 py-2 rounded-lg bg-red-600 text-white font-bold hover:bg-red-500 transition-colors">Reject</button>
                    <button id="acceptRequestBtn" class="flex-1 py-2 rounded-lg bg-green-600 text-black font-bold hover:bg-green-500 transition-colors">Accept</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Pending Request Modal -->
    <div id="pendingRequestModal" class="fixed inset-0 z-[100] hidden">
        <div class="absolute inset-0 bg-black/80 backdrop-blur-sm" onclick="window.app.closePendingRequestModal()"></div>
        <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-full max-w-md p-1">
            <div class="bg-gray-900 border border-gray-700 rounded-2xl p-6 shadow-2xl">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-xl font-bold text-white">Request Pending</h3>
                    <button onclick="window.app.closePendingRequestModal()" class="text-gray-400 hover
                </div>
                <p id="pendingRequestText" class="text-gray-300 text-sm mb-4"></p>
                <button onclick="window.app.closePendingRequestModal()" class="w-full py-2 rounded-lg bg-gray-700 text-white hover:bg-gray-600 transition-colors">OK</button>
            </div>
        </div>
    </div>

    <!-- Suspend User Modal -->
    <div id="suspendModal" class="fixed inset-0 z-[100] hidden">
        <div class="absolute inset-0 bg-black/80 backdrop-blur-sm" onclick="window.app.closeSuspendModal()"></div>
        <div class="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 w-full max-w-md p-1">
            <div class="bg-gray-900 border border-gray-700 rounded-2xl p-6 shadow-2xl">
                <div class="flex justify-between items-center mb-4">
                    <h3 id="suspendModalTitle" class="text-xl font-bold text-white">Suspend User</h3>
                    <button onclick="window.app.closeSuspendModal()" class="text-gray-400 hover:text-white"><i class="fa-solid fa-times"></i></button>
                </div>
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="block text-xs text-gray-400 mb-1">Days</label>
                        <input type="number" id="suspendDaysInput" min="0" placeholder="0" class="w-full bg-black border border-gray-700 rounded-lg p-3 text-white focus:border-red-500 focus:outline-none">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-400 mb-1">Hours</label>
                        <input type="number" id="suspendHoursInput" min="0" max="23" placeholder="0" class="w-full bg-black border border-gray-700 rounded-lg p-3 text-white focus:border-red-500 focus:outline-none">
                    </div>
                </div>
                <p class="text-gray-500 text-xs mb-4">Example: 50 days / 24 hours = 50 days and 24 hours suspension</p>
                <div class="flex gap-3">
                    <button onclick="window.app.closeSuspendModal()" class="flex-1 py-2 rounded-lg border border-gray-600 text-gray-300 hover:bg-gray-800 transition-colors">Cancel</button>
                    <button id="suspendSubmitBtn" class="flex-1 py-2 rounded-lg bg-red-600 text-white font-bold hover:bg-red-500 transition-colors">Suspend User</button>
                </div>
            </div>
        </div>
    </div>

    <div id="toast" class="fixed bottom-5 right-5 transform translate-y-20 opacity-0 transition-all duration-300 z-[110] bg-gray-800 border-l-4 border-green-500 text-white px-6 py-4 rounded shadow-2xl flex items-center gap-3">
        <i class="fa-solid fa-check-circle text-green-500"></i>
        <span id="toastMsg">Notification</span>
    </div>

</body>
</html>

